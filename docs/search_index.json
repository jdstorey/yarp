[
["index.html", "YARP, Yet Another R Primer A short introduction to R, R Markdown, and elements of the tidyverse", " YARP, Yet Another R Primer A short introduction to R, R Markdown, and elements of the tidyverse John D. Storey Created 2017-02-01; Last modified 2020-01-28 "],
["preface.html", "Preface", " Preface Hello, friend. This is yet another primer to get you started in R. I primarily created this to serve as a resource for students taking my courses at Princeton University. However, I’ve been told by others that they found it useful as both a primer and a quick reference. I’ve tried to make this primer as efficient as possible and provide the reader with what I consider to be the essentials. My experience is that the faster you can start using a statistical programming language such as R, the more likely you will appreciate its usefulness and continue to use it and learn. There isn’t a lot of discussion in this primer; it’s mostly examples in R. The content of this document started with an undergraduate course I developed, called Introduction to Data Science. In that course, I made slides using the amazing R package revealjs. I then developed Foundations of Applied Statistics and Data Science (with Applications in Biology), creating more advanced slides also using revealjs; these slides can be found at https://jdstorey.org/asdscourse2017/lectures/, and the source code at https://github.com/jdstorey/asdslectures. Although I no longer use these slides to teach my courses, I was nevertheless able to easily use the R Markdown as a starting point for this primer, using the bookdown package. This primer is organized into three main parts: R basics and programming, including reproducible data analysis and R Markdown Data wrangling, including dplyr Explortatory data analysis, including base graphics and ggplot2 Source Files The source files are maintained on GitHub: https://github.com/jdstorey/yarp Feel free to visit this repository to help me make the book better. About The Author John D. Storey received his PhD from Stanford University in statistics with a PhD minor in genetics. He then held faculty positions at the University of California, Berkeley and the University of Washington. Since 2008, he has a been a professor in the Lewis-Sigler Institute for Integrative Genomics at Princeton University. Storey’s research has been concerned with developing and applying statistical methods in genetics and genomics. He has made pioneering contributions to the development and application of methods for significance testing and inference on high-dimensional data. In 2014, Storey was appointed the founding Director of the Center for Statistics and Machine Learning at Princeton University and he was also named the William R. Harman ‘63 and Mary-Love Harman Professor in Genomics. He is an elected fellow of the American Association for the Advancement of Science as well as the Institute of Mathematical Statistics. He is the winner of the 2015 COPSS Presidents’ Award. He is also the winner of the 2015 Mortimer Spiegelman Award given by the American Public Health Association for outstanding contributions to public health statistics. "],
["r-basics.html", "1 R Basics 1.1 What is R? 1.2 Pros and Cons of R 1.3 RStudio 1.4 Getting Started in R", " 1 R Basics 1.1 What is R? R is a programming language, a high-level “interpreted language” R is an interactive environment R is used for doing statistics and data science 1.2 Pros and Cons of R R is free and open-source R stays on the cutting-edge because of its ability to utilize independently developed “packages” R has some peculiar featues that experienced programmers should note (see The R Inferno) R has an amazing community of passionate users and developers 1.3 RStudio RStudio is an IDE (integrated development environment) for R It contains many useful features for using R We will use the free version of RStudio in this course 1.4 Getting Started in R 1.4.1 Calculator Operations on numbers: + - * / ^ &gt; 2+1 [1] 3 &gt; 6+3*4-2^3 [1] 10 &gt; 6+(3*4)-(2^3) [1] 10 1.4.2 Atomic Classes There are five atomic classes (or modes) of objects in R: character complex integer logical numeric (real number) There is a sixth called “raw” that we will not discuss. 1.4.3 Assigning Values to Variables &gt; x &lt;- &quot;qcb508&quot; # character &gt; x &lt;- 2+1i # complex &gt; x &lt;- 4L # integer &gt; x &lt;- TRUE # logical &gt; x &lt;- 3.14159 # numeric Note: Anything typed after the # sign is not evaluated. The # sign allows you to add comments to your code. 1.4.4 More Ways to Assign Values &gt; x &lt;- 1 &gt; 1 -&gt; x &gt; x = 1 I recommend you only use x &lt;- 1 since = is used for variable assignments in function calls. 1.4.5 Evaluation When a complete expression is entered at the prompt, it is evaluated and the result of the evaluated expression is returned. The result may be auto-printed. &gt; x &lt;- 1 &gt; x+2 [1] 3 &gt; print(x) [1] 1 &gt; print(x+2) [1] 3 1.4.6 Functions There are many useful functions included in R. “Packages” (covered later) can be loaded as libraries to provide additional functions. You can also write your own functions in any R session. Here are some examples of built-in functions: &gt; x &lt;- 2 &gt; print(x) [1] 2 &gt; sqrt(x) [1] 1.414214 &gt; log(x) [1] 0.6931472 &gt; class(x) [1] &quot;numeric&quot; &gt; is.vector(x) [1] TRUE 1.4.7 Accessing Help in R You can open the help file for any function by typing ? with the functions name. Here is an example: &gt; ?sqrt There’s also a function help.search that can do general searches for help. You can learn about it by typing: &gt; ?help.search It’s also useful to use Google: for example, “r help square root”. The R help files are also on the web. 1.4.8 Variable Names In the previous examples, we used x as our variable name. Do not use the following variable names, as they have special meanings in R: c, q, s, t, C, D, F, I, T When combining two words for a given variable, I recommend one of these common styles: &gt; my_variable &lt;- 1 &gt; myVariable &lt;- 1 Variable names such as my.variable are problematic because of the special use of “.” in R. 1.4.9 Vectors The vector is the most basic object in R. You can create vectors in a number of ways. &gt; x &lt;- c(1, 2, 3, 4, 5) &gt; x [1] 1 2 3 4 5 &gt; &gt; y &lt;- 1:40 &gt; y [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 &gt; &gt; z &lt;- seq(from=0, to=100, by=10) &gt; z [1] 0 10 20 30 40 50 60 70 80 90 100 &gt; length(z) [1] 11 1.4.10 Vectors Programmers: vectors are indexed starting at 1, not 0 A vector can only contain elements of a single class: &gt; x &lt;- &quot;a&quot; &gt; x[0] character(0) &gt; x[1] [1] &quot;a&quot; &gt; &gt; y &lt;- 1:3 &gt; z &lt;- c(x, y, TRUE, FALSE) &gt; z [1] &quot;a&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;TRUE&quot; &quot;FALSE&quot; 1.4.11 Matrices Like vectors, matrices are objects that can contain elements of only one class. &gt; m &lt;- matrix(1:6, nrow=2, ncol=3) &gt; m [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 &gt; &gt; m &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) &gt; m [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 1.4.12 Factors In statistics, factors encode categorical data. &gt; paint &lt;- factor(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, + &quot;red&quot;)) &gt; paint [1] red white blue blue red red Levels: blue red white &gt; &gt; table(paint) paint blue red white 2 3 1 &gt; unclass(paint) [1] 2 3 1 1 2 2 attr(,&quot;levels&quot;) [1] &quot;blue&quot; &quot;red&quot; &quot;white&quot; 1.4.13 Lists Lists allow you to hold different classes of objects in one variable. &gt; x &lt;- list(1:3, &quot;a&quot;, c(TRUE, FALSE)) &gt; x [[1]] [1] 1 2 3 [[2]] [1] &quot;a&quot; [[3]] [1] TRUE FALSE &gt; &gt; ## access any element of the list &gt; x[[2]] [1] &quot;a&quot; &gt; x[[3]][2] [1] FALSE 1.4.14 Lists with Names The elements of a list can be given names. &gt; x &lt;- list(counting=1:3, char=&quot;a&quot;, logic=c(TRUE, FALSE)) &gt; x $counting [1] 1 2 3 $char [1] &quot;a&quot; $logic [1] TRUE FALSE &gt; &gt; ## access any element of the list &gt; x$char [1] &quot;a&quot; &gt; x$logic[2] [1] FALSE 1.4.15 Missing Values In data analysis and model fitting, we often have missing values. NA represents missing values and NaN means “not a number”, which is a special type of missing value. &gt; m &lt;- matrix(nrow=3, ncol=3) &gt; m [,1] [,2] [,3] [1,] NA NA NA [2,] NA NA NA [3,] NA NA NA &gt; 0/1 [1] 0 &gt; 1/0 [1] Inf &gt; 0/0 [1] NaN 1.4.16 NULL NULL is a special type of reserved value in R. &gt; x &lt;- vector(mode=&quot;list&quot;, length=3) &gt; x [[1]] NULL [[2]] NULL [[3]] NULL 1.4.17 Coercion We saw earlier that when we mixed classes in a vector they were all coerced to be of type character: &gt; c(&quot;a&quot;, 1:3, TRUE, FALSE) [1] &quot;a&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;TRUE&quot; &quot;FALSE&quot; You can directly apply coercion with functions as.numeric(), as.character(), as.logical(), etc. This doesn’t always work out well: &gt; x &lt;- 1:3 &gt; as.character(x) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &gt; &gt; y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &gt; as.numeric(y) Warning: NAs introduced by coercion [1] NA NA NA 1.4.18 Data Frames The data frame is one of the most important objects in R. Data sets very often come in tabular form of mixed classes, and data frames are constructed exactly for this. Data frames are lists where each element has the same length. 1.4.19 Data Frames &gt; df &lt;- data.frame(counting=1:3, char=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), + logic=c(TRUE, FALSE, TRUE)) &gt; df counting char logic 1 1 a TRUE 2 2 b FALSE 3 3 c TRUE &gt; &gt; nrow(df) [1] 3 &gt; ncol(df) [1] 3 1.4.20 Data Frames &gt; dim(df) [1] 3 3 &gt; &gt; names(df) [1] &quot;counting&quot; &quot;char&quot; &quot;logic&quot; &gt; &gt; attributes(df) $names [1] &quot;counting&quot; &quot;char&quot; &quot;logic&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 1.4.21 Attributes Attributes give information (or meta-data) about R objects. The previous slide shows attributes(df), the attributes of the data frame df. &gt; x &lt;- 1:3 &gt; attributes(x) # no attributes for a standard vector NULL &gt; &gt; m &lt;- matrix(1:6, nrow=2, ncol=3) &gt; attributes(m) $dim [1] 2 3 &gt; paint &lt;- factor(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, + &quot;red&quot;)) &gt; attributes(paint) $levels [1] &quot;blue&quot; &quot;red&quot; &quot;white&quot; $class [1] &quot;factor&quot; 1.4.22 Names Names can be assigned to columns and rows of vectors, matrices, and data frames. This makes your code easier to write and read. &gt; names(x) &lt;- c(&quot;Princeton&quot;, &quot;Rutgers&quot;, &quot;Penn&quot;) &gt; x Princeton Rutgers Penn 1 2 3 &gt; &gt; colnames(m) &lt;- c(&quot;NJ&quot;, &quot;NY&quot;, &quot;PA&quot;) &gt; rownames(m) &lt;- c(&quot;East&quot;, &quot;West&quot;) &gt; m NJ NY PA East 1 3 5 West 2 4 6 &gt; colnames(m) [1] &quot;NJ&quot; &quot;NY&quot; &quot;PA&quot; 1.4.23 Accessing Names Displaying or assigning names to these three types of objects does not have consistent syntax. Object Column Names Row Names vector names() N/A data frame names() row.names() data frame colnames() rownames() matrix colnames() rownames() "],
["reproducible-data-analysis.html", "2 Reproducible Data Analysis 2.1 Definition and Motivation 2.2 Reproducible vs. Replicable 2.3 Steps to a Reproducible Analysis 2.4 Organizing Your Data Analysis 2.5 Common Mistakes 2.6 R Markdown", " 2 Reproducible Data Analysis 2.1 Definition and Motivation Reproducibility involves being able to recalculate the exact numbers in a data analysis using the code and raw data provided by the analyst. Reproducibility is often difficult to achieve and has slowed down the discovery of important data analytic errors. Reproducibility should not be confused with “correctness” of a data analysis. A data analysis can be fully reproducible and recreate all numbers in an analysis and still be misleading or incorrect. From Elements of Data Analytic Style, by Leek 2.2 Reproducible vs. Replicable Reproducible research is often used these days to indicate the ability to recalculate the exact numbers in a data analysis Replicable research results often refers to the ability to independently carry out a study (thereby collecting new data) and coming to equivalent conclusions as the original study These two terms are often confused, so it is important to clearly state the definition 2.3 Steps to a Reproducible Analysis Use a data analysis script – e.g., R Markdown (discussed next section!) or iPython Notebooks Record versions of software and paramaters – e.g., use sessionInfo() in R as in hw_1.Rmd Organize your data analysis Use version control – e.g., GitHub Set a random number generator seed – e.g., use set.seed() in R Have someone else run your analysis 2.4 Organizing Your Data Analysis Data raw data processed data (sometimes multiple stages for very large data sets) Figures Exploratory figures Final figures R code Raw or unused scripts Data processing scripts Analysis scripts Text README files explaining what all the components are Final data analysis products like presentations/writeups 2.5 Common Mistakes Failing to use a script for your analysis Not recording software and package version numbers or other settings used Not sharing your data and code Using reproducibility as a social weapon 2.6 R Markdown 2.6.1 R + Markdown + knitr R Markdown was developed by the RStudio team to allow one to write reproducible research documents using Markdown and knitr. This is contained in the rmarkdown package, but can easily be carried out in RStudio. Markdown was originally developed as a very simply text-to-html conversion tool. With Pandoc, Markdown is a very simply text-to-X conversion tool where X can be many different formats: html, LaTeX, PDF, Word, etc. 2.6.2 R Markdown Files R Markdown documents begin with a metadata section, the YAML header, that can include information on the title, author, and date as well as options for customizing output. title: &quot;QCB 508 -- Homework 1&quot; author: &quot;Your Name&quot; date: February 23, 2017 output: pdf_document Many options are available. See http://rmarkdown.rstudio.com for full documentation. 2.6.3 Markdown Headers: # Header 1 ## Header 2 ### Header 3 Emphasis: *italic* **bold** _italic_ __bold__ Tables: First Header | Second Header ------------- | ------------- Content Cell | Content Cell Content Cell | Content Cell Unordered list: - Item 1 - Item 2 - Item 2a - Item 2b Ordered list: 1. Item 1 2. Item 2 3. Item 3 - Item 3a - Item 3b Links: http://example.com [linked phrase](http://example.com) Blockquotes: Florence Nightingale once said: &gt; For the sick it is important &gt; to have the best. Plain code blocks: ``` This text is displayed verbatim with no formatting. ``` Inline Code: We use the `print()` function to print the contents of a variable in R. Additional documentation and examples can be found here and here. 2.6.4 LaTeX LaTeX is a markup language for technical writing, especially for mathematics. It can be include in R Markdown files. For example, $y = a + bx + \\epsilon$ produces \\(y = a + bx + \\epsilon\\) Here is an introduction to LaTeX and here is a primer on LaTeX for R Markdown. 2.6.5 knitr The knitr R package allows one to execute R code within a document, and to display the code itself and its output (if desired). This is particularly easy to do in the R Markdown setting. For example… Placing the following text in an R Markdown file The sum of 2 and 2 is `r 2+2`. produces in the output file The sum of 2 and 2 is 4. 2.6.6 knitr Chunks Chunks of R code separated from the text. In R Markdown: ```{r} x &lt;- 2 x + 1 print(x) ``` Output in file: &gt; x &lt;- 2 &gt; x + 1 [1] 3 &gt; print(x) [1] 2 2.6.7 Chunk Option: echo In R Markdown: ```{r, echo=FALSE} x &lt;- 2 x + 1 print(x) ``` Output in file: [1] 3 [1] 2 2.6.8 Chunk Option: results In R Markdown: ```{r, results=&quot;hide&quot;} x &lt;- 2 x + 1 print(x) ``` Output in file: &gt; x &lt;- 2 &gt; x + 1 &gt; print(x) 2.6.9 Chunk Option: include In R Markdown: ```{r, include=FALSE} x &lt;- 2 x + 1 print(x) ``` Output in file: (nothing) 2.6.10 Chunk Option: eval In R Markdown: ```{r, eval=FALSE} x &lt;- 2 x + 1 print(x) ``` Output in file: &gt; x &lt;- 2 &gt; x + 1 &gt; print(x) 2.6.11 Chunk Names Naming your chunks can be useful for identifying them in your file and during the execution, and also to denote dependencies among chunks. ```{r my_first_chunk} x &lt;- 2 x + 1 print(x) ``` 2.6.12 knitr Option: cache Sometimes you don’t want to run chunks over and over, especially for large calculations. You can “cache” them. ```{r chunk1, cache=TRUE, include=FALSE} x &lt;- 2 ``` ```{r chunk2, cache=TRUE, dependson=&quot;chunk1&quot;} y &lt;- 3 z &lt;- x + y ``` This creates a directory called cache in your working directory that stores the objects created or modified in these chunks. When chunk1 is modified, it is re-run. Since chunk2 depends on chunk1, it will also be re-run. 2.6.13 knitr Options: figures You can add chunk options regarding the placement and size of figures. Examples include: fig.width fig.height fig.align 2.6.14 Changing Default Chunk Settings If you will be using the same options on most chunks, you can set default options for the entire document. Run something like this at the beginning of your document with your desired chunk options. ```{r my_opts, cache=FALSE, echo=FALSE} library(&quot;knitr&quot;) opts_chunk$set(fig.align=&quot;center&quot;, fig.height=4, fig.width=6) ``` 2.6.15 Documentation and Examples http://yihui.name/knitr/ http://kbroman.org/knitr_knutshell/pages/Rmarkdown.html https://github.com/jdstorey/asdslectures "],
["r-programming.html", "3 R Programming 3.1 Control Structures 3.2 Vectorized Operations 3.3 Subsetting R Objects 3.4 Functions 3.5 Environment 3.6 Packages 3.7 Organizing Your Code", " 3 R Programming 3.1 Control Structures 3.1.1 Rationale Control structures in R allow you to control the flow of execution of a series of R expressions They allow you to put some logic into your R code, rather than just always executing the same R code every time Control structures also allow you to respond to inputs or to features of the data and execute different R expressions accordingly Paraphrased from R Programming for Data Science, by Peng 3.1.2 Common Control Structures if and else: testing a condition and acting on it for: execute a loop a fixed number of times while: execute a loop while a condition is true repeat: execute an infinite loop (must break out of it to stop) break: break the execution of a loop next: skip an interation of a loop From R Programming for Data Science, by Peng 3.1.3 Some Boolean Logic R has built-in functions that produce TRUE or FALSE such as is.vector or is.na. You can also do the following: x == y : does x equal y? x &gt; y : is x greater than y? (also &lt; less than) x &gt;= y : is x greater than or equal to y? x &amp;&amp; y : are both x and y true? x || y : is either x or y true? !is.vector(x) : this is TRUE if x is not a vector 3.1.4 if Idea: if(&lt;condition&gt;) { ## do something } ### Continue with rest of code Example: &gt; x &lt;- c(1,2,3) &gt; if(is.numeric(x)) { + x+2 + } [1] 3 4 5 3.1.5 if-else Idea: if(&lt;condition&gt;) { ## do something } else { ## do something else } Example: &gt; x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &gt; if(is.numeric(x)) { + print(x+2) + } else { + class(x) + } [1] &quot;character&quot; 3.1.6 for Loops Example: &gt; for(i in 1:10) { + print(i) + } [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 [1] 7 [1] 8 [1] 9 [1] 10 Examples: &gt; x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) &gt; &gt; for(i in 1:4) { + print(x[i]) + } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;d&quot; &gt; &gt; for(i in seq_along(x)) { + print(x[i]) + } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;d&quot; 3.1.7 Nested for Loops Example: &gt; m &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) &gt; &gt; for(i in seq_len(nrow(m))) { + for(j in seq_len(ncol(m))) { + print(m[i,j]) + } + } [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 3.1.8 while Example: &gt; x &lt;- 1:10 &gt; idx &lt;- 1 &gt; &gt; while(x[idx] &lt; 4) { + print(x[idx]) + idx &lt;- idx + 1 + } [1] 1 [1] 2 [1] 3 &gt; &gt; idx [1] 4 Repeats the loop until while the condition is TRUE. 3.1.9 repeat Example: &gt; x &lt;- 1:10 &gt; idx &lt;- 1 &gt; &gt; repeat { + print(x[idx]) + idx &lt;- idx + 1 + if(idx &gt;= 4) { + break + } + } [1] 1 [1] 2 [1] 3 &gt; &gt; idx [1] 4 Repeats the loop until break is executed. 3.1.10 break and next break ends the loop. next skips the rest of the current loop iteration. Example: &gt; x &lt;- 1:1000 &gt; for(idx in 1:1000) { + # %% calculates division remainder + if((x[idx] %% 2) &gt; 0) { + next + } else if(x[idx] &gt; 10) { # an else-if!! + break + } else { + print(x[idx]) + } + } [1] 2 [1] 4 [1] 6 [1] 8 [1] 10 3.2 Vectorized Operations 3.2.1 Calculations on Vectors R is usually smart about doing calculations with vectors. Examples: &gt; &gt; x &lt;- 1:3 &gt; y &lt;- 4:6 &gt; &gt; 2*x # same as c(2*x[1], 2*x[2], 2*x[3]) [1] 2 4 6 &gt; x + 1 # same as c(x[1]+1, x[2]+1, x[3]+1) [1] 2 3 4 &gt; x + y # same as c(x[1]+y[1], x[2]+y[2], x[3]+y[3]) [1] 5 7 9 &gt; x*y # same as c(x[1]*y[1], x[2]*y[2], x[3]*y[3]) [1] 4 10 18 3.2.2 A Caveat If two vectors are of different lengths, R tries to find a solution for you (and doesn’t always tell you). &gt; x &lt;- 1:5 &gt; y &lt;- 1:2 &gt; x+y Warning in x + y: longer object length is not a multiple of shorter object length [1] 2 4 4 6 6 What happened here? 3.2.3 Vectorized Matrix Operations Operations on matrices are also vectorized. Example: &gt; x &lt;- matrix(1:4, nrow=2, ncol=2, byrow=TRUE) &gt; y &lt;- matrix(1:4, nrow=2, ncol=2) &gt; &gt; x+y [,1] [,2] [1,] 2 5 [2,] 5 8 &gt; &gt; x*y [,1] [,2] [1,] 1 6 [2,] 6 16 3.2.4 Mixing Vectors and Matrices What happens when we do calculations involving a vector and a matrix? Example: &gt; x &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) &gt; z &lt;- 1:2 &gt; &gt; x + z [,1] [,2] [,3] [1,] 2 3 4 [2,] 6 7 8 &gt; &gt; x * z [,1] [,2] [,3] [1,] 1 2 3 [2,] 8 10 12 3.2.5 Mixing Vectors and Matrices Another example: &gt; x &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) &gt; z &lt;- 1:3 &gt; &gt; x + z [,1] [,2] [,3] [1,] 2 5 5 [2,] 6 6 9 &gt; &gt; x * z [,1] [,2] [,3] [1,] 1 6 6 [2,] 8 5 18 What happened this time? 3.2.6 Vectorized Boolean Logic We saw &amp;&amp; and || applied to pairs of logical values. We can also vectorize these operations. &gt; a &lt;- c(TRUE, TRUE, FALSE) &gt; b &lt;- c(FALSE, TRUE, FALSE) &gt; &gt; a | b [1] TRUE TRUE FALSE &gt; a &amp; b [1] FALSE TRUE FALSE 3.3 Subsetting R Objects 3.3.1 Subsetting Vectors &gt; x &lt;- 1:8 &gt; &gt; x[1] # extract the first element [1] 1 &gt; x[2] # extract the second element [1] 2 &gt; &gt; x[1:4] # extract the first 4 elements [1] 1 2 3 4 &gt; &gt; x[c(1, 3, 4)] # extract elements 1, 3, and 4 [1] 1 3 4 &gt; x[-c(1, 3, 4)] # extract all elements EXCEPT 1, 3, and 4 [1] 2 5 6 7 8 3.3.2 Subsetting Vectors &gt; names(x) &lt;- letters[1:8] &gt; x a b c d e f g h 1 2 3 4 5 6 7 8 &gt; &gt; x[c(&quot;a&quot;, &quot;b&quot;, &quot;f&quot;)] a b f 1 2 6 &gt; &gt; s &lt;- x &gt; 3 &gt; s a b c d e f g h FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE &gt; x[s] d e f g h 4 5 6 7 8 3.3.3 Subsettng Matrices &gt; x &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) &gt; x [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 &gt; &gt; x[1,2] [1] 2 &gt; x[1, ] [1] 1 2 3 &gt; x[ ,2] [1] 2 5 3.3.4 Subsettng Matrices &gt; colnames(x) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) &gt; &gt; x[ , c(&quot;B&quot;, &quot;C&quot;)] B C [1,] 2 3 [2,] 5 6 &gt; &gt; x[c(FALSE, TRUE), c(&quot;B&quot;, &quot;C&quot;)] B C 5 6 &gt; &gt; x[2, c(&quot;B&quot;, &quot;C&quot;)] B C 5 6 3.3.5 Subsettng Matrices &gt; s &lt;- (x %% 2) == 0 &gt; s A B C [1,] FALSE TRUE FALSE [2,] TRUE FALSE TRUE &gt; &gt; x[s] [1] 4 2 6 &gt; &gt; x[c(2, 3, 6)] [1] 4 2 6 3.3.6 Subsetting Lists &gt; x &lt;- list(my=1:3, favorite=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), + course=c(FALSE, TRUE, NA)) &gt; &gt; x[[1]] [1] 1 2 3 &gt; x[[&quot;my&quot;]] [1] 1 2 3 &gt; x$my [1] 1 2 3 &gt; x[[c(3,1)]] [1] FALSE &gt; x[[3]][1] [1] FALSE &gt; x[c(3,1)] $course [1] FALSE TRUE NA $my [1] 1 2 3 3.3.7 Subsetting Data Frames &gt; x &lt;- data.frame(my=1:3, favorite=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), + course=c(FALSE, TRUE, NA)) &gt; &gt; x[[1]] [1] 1 2 3 &gt; x[[&quot;my&quot;]] [1] 1 2 3 &gt; x$my [1] 1 2 3 &gt; x[[c(3,1)]] [1] FALSE &gt; x[[3]][1] [1] FALSE &gt; x[c(3,1)] course my 1 FALSE 1 2 TRUE 2 3 NA 3 3.3.8 Subsetting Data Frames &gt; x &lt;- data.frame(my=1:3, favorite=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), + course=c(FALSE, TRUE, NA)) &gt; &gt; x[1, ] my favorite course 1 1 a FALSE &gt; x[ ,3] [1] FALSE TRUE NA &gt; x[ ,&quot;favorite&quot;] [1] a b c Levels: a b c &gt; x[1:2, ] my favorite course 1 1 a FALSE 2 2 b TRUE &gt; x[ ,2:3] favorite course 1 a FALSE 2 b TRUE 3 c NA 3.3.9 Note on Data Frames R often converts character strings to factors unless you specify otherwise. In the previous slide, we saw it converted the “favorite” column to factors. Let’s fix that… &gt; x &lt;- data.frame(my=1:3, favorite=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), + course=c(FALSE, TRUE, NA), + stringsAsFactors=FALSE) &gt; &gt; x[ ,&quot;favorite&quot;] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &gt; class(x[ ,&quot;favorite&quot;]) [1] &quot;character&quot; 3.3.10 Missing Values &gt; data(&quot;airquality&quot;, package=&quot;datasets&quot;) &gt; head(airquality) Ozone Solar.R Wind Temp Month Day 1 41 190 7.4 67 5 1 2 36 118 8.0 72 5 2 3 12 149 12.6 74 5 3 4 18 313 11.5 62 5 4 5 NA NA 14.3 56 5 5 6 28 NA 14.9 66 5 6 &gt; dim(airquality) [1] 153 6 &gt; which(is.na(airquality$Ozone)) [1] 5 10 25 26 27 32 33 34 35 36 37 39 42 43 45 46 52 [18] 53 54 55 56 57 58 59 60 61 65 72 75 83 84 102 103 107 [35] 115 119 150 &gt; sum(is.na(airquality$Ozone)) [1] 37 3.3.11 Subsetting by Matching &gt; letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &gt; vowels &lt;- c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;) &gt; &gt; letters %in% vowels [1] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE [12] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE TRUE FALSE [23] FALSE FALSE FALSE FALSE &gt; which(letters %in% vowels) [1] 1 5 9 15 21 &gt; &gt; letters[which(letters %in% vowels)] [1] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; &quot;u&quot; 3.3.12 Advanced Subsetting The R Programming for Data Science chapter titled “Subsetting R Objects” contains additional material on subsetting that you should know. The Advanced R website contains more detailed information on subsetting that you may find useful. 3.4 Functions 3.4.1 Rationale Writing functions is a core activity of an R programmer. It represents the key step of the transition from a mere user to a developer who creates new functionality for R. Functions are often used to encapsulate a sequence of expressions that need to be executed numerous times, perhaps under slightly different conditions. Functions are also often written when code must be shared with others or the public. From R Programming for Data Science, by Peng 3.4.2 Defining a New Function Functions are defined using the function() directive They are stored as variables, so they can be passed to other functions and assigned to new variables Arguments and a final return object are defined 3.4.3 Example 1 &gt; my_square &lt;- function(x) { + x*x # can also do return(x*x) + } &gt; &gt; my_square(x=2) [1] 4 &gt; &gt; my_fun2 &lt;- my_square &gt; my_fun2(x=3) [1] 9 3.4.4 Example 2 &gt; my_square_ext &lt;- function(x) { + y &lt;- x*x + return(list(x_original=x, x_squared=y)) + } &gt; &gt; my_square_ext(x=2) $x_original [1] 2 $x_squared [1] 4 &gt; &gt; z &lt;- my_square_ext(x=2) 3.4.5 Example 3 &gt; my_power &lt;- function(x, e, say_hello) { + if(say_hello) { + cat(&quot;Hello World!&quot;) + } + x^e + } &gt; &gt; my_power(x=2, e=3, say_hello=TRUE) Hello World! [1] 8 &gt; &gt; z &lt;- my_power(x=2, e=3, say_hello=TRUE) Hello World! &gt; z [1] 8 3.4.6 Default Function Argument Values Some functions have default values for their arguments: &gt; str(matrix) function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) You can define a function with default values by the following: f &lt;- function(x, y=2) { x + y } If the user types f(x=1) then it defaults to y=2, but if the user types f(x=1, y=3), then it executes with these assignments. 3.4.7 The Ellipsis Argument You will encounter functions that include as a possible argument the ellipsis: ... This basically holds arguments that can be passed to functions called within a function. Example: &gt; double_log &lt;- function(x, ...) { + log((2*x), ...) + } &gt; &gt; double_log(x=1, base=2) [1] 1 &gt; double_log(x=1, base=10) [1] 0.30103 3.4.8 Argument Matching R tries to automatically deal with function calls when the arguments are not defined explicity. For example: x &lt;- matrix(1:6, nrow=2, ncol=3, byrow=TRUE) # versus x &lt;- matrix(1:6, 2, 3, TRUE) I strongly recommend that you define arguments explcitly. For example, I can never remember which comes first in matrix(), nrow or ncol. 3.5 Environment 3.5.1 Loading .RData Files An .RData file is a binary file containing R objects. These can be saved from your current R session and also loaded into your current session. &gt; # generally... &gt; # to load: &gt; load(file=&quot;path/to/file_name.RData&quot;) &gt; # to save: &gt; save(file=&quot;path/to/file_name.RData&quot;) &gt; ## assumes file in working directory &gt; load(file=&quot;project_1_R_basics.RData&quot;) &gt; ## loads from our GitHub repository &gt; load(file=url(&quot;https://github.com/SML201/project1/raw/ + master/project_1_R_basics.RData&quot;)) 3.5.2 Listing Objects The objects in your current R session can be listed. An environment can also be specificied in case you have objects stored in different environments. &gt; ls() [1] &quot;num_people_in_precept&quot; &quot;SML201_grade_distribution&quot; [3] &quot;some_ORFE_profs&quot; &gt; &gt; ls(name=globalenv()) [1] &quot;num_people_in_precept&quot; &quot;SML201_grade_distribution&quot; [3] &quot;some_ORFE_profs&quot; &gt; &gt; ## see help file for other options &gt; ?ls 3.5.3 Removing Objects You can remove specific objects or all objects from your R environment of choice. &gt; rm(&quot;some_ORFE_profs&quot;) # removes variable some_ORFE_profs &gt; &gt; rm(list=ls()) # Removes all variables from environment 3.5.4 Advanced The R environment is there to connect object names to object values. The R Programming for Data Science chapter titled “Scoping Rules of R” discussed environments and object names in more detail than we need for this course. A useful discussion about environments can also be found on the Advanced R web site. 3.6 Packages 3.6.1 Rationale “In R, the fundamental unit of shareable code is the package. A package bundles together code, data, documentation, and tests, and is easy to share with others. As of January 2015, there were over 6,000 packages available on the Comprehensive R Archive Network, or CRAN, the public clearing house for R packages. This huge variety of packages is one of the reasons that R is so successful: the chances are that someone has already solved a problem that you’re working on, and you can benefit from their work by downloading their package.” From http://r-pkgs.had.co.nz/intro.html by Hadley Wickham 3.6.2 Contents of a Package R functions R data objects Help documents for using the package Information on the authors, dependencies, etc. Information to make sure it “plays well” with R and other packages 3.6.3 Installing Packages From CRAN: install.packages(&quot;dplyr&quot;) From GitHub (for advanced users): library(&quot;devtools&quot;) install_github(&quot;hadley/dplyr&quot;) From Bioconductor (basically CRAN for biology): library(&quot;BiocManager&quot;) BiocManager::install(&quot;qvalue&quot;) Be very careful about dependencies when installing from GitHub. Multiple packages: install.packages(c(&quot;dplyr&quot;, &quot;ggplot2&quot;)) Install all dependencies: install.packages(c(&quot;dplyr&quot;, &quot;ggplot2&quot;), dependencies=TRUE) Updating packages: update.packages() 3.6.4 Loading Packages Two ways to load a package: library(&quot;dplyr&quot;) library(dplyr) I prefer the former. 3.6.5 Getting Started with a Package When you install a new package and load it, what’s next? I like to look at the help files and see what functions and data sets a package has. library(&quot;dplyr&quot;) help(package=&quot;dplyr&quot;) 3.6.6 Specifying a Function within a Package You can call a function from a specific package. Suppose you are in a setting where you have two packages loaded that have functions with the same name. dplyr::arrange(mtcars, cyl, disp) This calls the arrange functin specifically from dplyr. The package plyr also has an arrange function. 3.6.7 More on Packages We will be covering several highly used R packages in depth this semester, so we will continue to learn about packages, how they are organized, and how they are used. You can download the “source” of a package from R and take a look at the contents if you want to dig deeper. There are also many good tutorials on creating packages, such as http://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/. 3.7 Organizing Your Code 3.7.1 Suggestions RStudio conveniently tries to automatically format your R code. We suggest the following in general. 1. No more than 80 characters per line (or fewer depending on how R Markdown compiles): really_long_line &lt;- my_function(x=20, y=30, z=TRUE, a=&quot;Joe&quot;, b=3.8) 2. Indent 2 or more characters for nested commands: for(i in 1:10) { if(i &gt; 4) { print(i) } } 3. Generously comment your code. ## a for-loop that prints the index ## whenever it is greater than 4 for(i in 1:10) { if(i &gt; 4) { print(i) } } ## a good way to get partial credit ## if something goes wrong :-) 4. Do not hesitate to write functions to organize tasks. These help to break up your code into more undertsandable pieces, and functions can often be used several times. 3.7.2 Where to Put Files See the Elements of Data Analytic Style chapter titled “Reproducibility” for suggestions on how to organize your files. In this course, we will keep this relatively simple. We will try to provide you with some organization when distributing the projects. "],
["getting-data-in-and-out-of-r.html", "4 Getting Data In and Out of R 4.1 .RData Files 4.2 readr Package 4.3 Scraping from the Web 4.4 APIs", " 4 Getting Data In and Out of R 4.1 .RData Files R objects can be saved to binary .RData files and loaded with the save (or save.image) and load functions, respectively. This is the easiest way to get data into R. 4.2 readr Package There are a number of R packages that provide more sophisticated tools for getting data in and out of R, especially as data sets have become larger and larger. One of those packages is readr for text files. It reads and writes data quickly, provides a useful status bar for large files, and does a good job at determining data types. readr is organized similarly to the base R functions. For example, there are functions read_table, read_csv, write_tsv, and write_csv. See also fread and fwrite from the data.table package. 4.3 Scraping from the Web There are several packages that facilitate “scraping” data from the web, including rvest demonstrated here. &gt; library(&quot;rvest&quot;) &gt; schedule &lt;- read_html(&quot;http://jdstorey.github.io/asdscourse/schedule/&quot;) &gt; first_table &lt;- html_table(schedule)[[1]] &gt; names(first_table) &lt;- c(&quot;week&quot;, &quot;topics&quot;, &quot;reading&quot;) &gt; first_table[2,&quot;week&quot;] &gt; first_table[2,&quot;topics&quot;] %&gt;% strsplit(split=&quot; &quot;) &gt; first_table[2,&quot;reading&quot;] %&gt;% strsplit(split=&quot; &quot;) &gt; grep(&quot;R4DS&quot;, first_table$reading) # which rows (weeks) have R4DS The rvest documentation recommends SelectorGadget, which is “a javascript bookmarklet that allows you to interactively figure out what css selector you need to extract desired components from a page.” &gt; usg_url &lt;- &quot;https://princetonusg.com/senate/&quot; &gt; usg &lt;- read_html(usg_url) &gt; officers &lt;- html_nodes(usg, &quot;.team-member-name&quot;) %&gt;% + html_text &gt; head(officers, n=20) 4.4 APIs API stands for “application programming interface” which is a set of routines, protocols, and tools for building software and applications. A specific website may provide an API for scraping data from that website. There are R packages that provide an interface with specific APIs, such as the twitteR package. "],
["data-wrangling-chapter.html", "5 Data Wrangling 5.1 Definition 5.2 Wrangling Challenges", " 5 Data Wrangling 5.1 Definition Data wrangling is loosely defined as the process of manually converting or mapping data from one “raw” form into another format that allows for more convenient consumption of the data with the help of semi-automated tools. It typically follows a set of general steps which begin with extracting the data in a raw form from the data source, “wrangling” the raw data using algorithms (e.g. sorting) or parsing the data into predefined data structures, and finally depositing the resulting content into a data sink for storage and future use. https://en.wikipedia.org/wiki/Data_wrangling 5.2 Wrangling Challenges Some of the challenges encountered in data wrangling are: Importing files Organizing data sets Transforming data Combining data sets Dealing with various data types (e.g., dates) Identifying errors "],
["tidy-data.html", "6 Tidy Data 6.1 Motivation 6.2 Definition 6.3 Example: Titanic Data 6.4 Rules of Thumb", " 6 Tidy Data 6.1 Motivation “Happy families are all alike; every unhappy family is unhappy in its own way.” – Leo Tolstoy “Tidy datasets are all alike, but every messy dataset is messy in its own way.” – Hadley Wickham From R for Data Science. 6.2 Definition Tidy datasets are easy to manipulate, model and visualize, and have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table. From Wickham (2014), “Tidy Data”, Journal of Statistical Software A dataset is a collection of values, usually either numbers (if quantitative) or strings (if qualitative). Values are organized in two ways. Every value belongs to a variable and an observation. A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units. An observation contains all values measured on the same unit (like a person, or a day, or a race) across attributes. From: Wickham H (2014), “Tidy Data”, Journal of Statistical Software 6.3 Example: Titanic Data According to the Titanic data from the datasets package: 367 males survived, 1364 males perished, 344 females survived, and 126 females perished. How should we organize these data? 6.3.1 Intuitive Format Survived Perished Male 367 1364 Female 344 126 6.3.2 Tidy Format fate sex number perished male 1364 perished female 126 survived male 367 survived female 344 6.4 Rules of Thumb Something is a value if it represents different forms of a common object and it changes throughout the data set. Something is a value if the data can be arranged so that it appears across rows within a column and this makes sense. For example, fate and sex do not satisfy these criteria in the Titanic data, but perished/survived and female/male do. "],
["tidyverse.html", "7 Tidyverse 7.1 Idea 7.2 Packages 7.3 Primary Packages 7.4 Tidying Data 7.5 Reshaping Data", " 7 Tidyverse 7.1 Idea When the data are in tidy format, one can design functions around this format to consistently and intuitively perform data wrangling and analysis operations. The packages containing these are called the “tidyverse.” Note: The idea of tidy data was first proposed by Hadley Wickham and he created several of the core packages, so this used to be called (semi-seriously) the “hadleyverse.” 7.2 Packages The tidyverse is a set of packages that work in harmony because they share common data representations and API design. The tidyverse package is designed to make it easy to install and load core packages from the tidyverse in a single command. https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/ 7.3 Primary Packages dplyr: data manipulation ggplot2: data visualization purrr: functional programming readr: data import tibble: modernization of data frames tidyr: data tidying Loading tidyverse: &gt; library(tidyverse) 7.4 Tidying Data 7.4.1 tidyr Package This package provides a variety of functions that allow one to tidy data. Importantly, it solves two common ways that data come as untidy. gather(): Gathers a variable distributed across two or more columns into a single column. spread(): Spreads a column containing two or more variables into one column per variable. 7.4.2 Untidy Titanic Data This does not satisfy the definition of tidy data because a variable’s observations are distributed as column names. &gt; df &lt;- tibble(sex=c(&quot;male&quot;, &quot;female&quot;), + survived=c(367, 344), + perished=c(1364, 126)) &gt; df # A tibble: 2 x 3 sex survived perished &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 male 367 1364 2 female 344 126 7.4.3 gather() We apply the gather() function to make a column containing the survived and perished observations. &gt; df &lt;- gather(df, survived, perished, + key=&quot;fate&quot;, value=&quot;number&quot;) &gt; df # A tibble: 4 x 3 sex fate number &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 male survived 367 2 female survived 344 3 male perished 1364 4 female perished 126 7.4.4 spread() This example is here to show that spread() does the opposite operation as gather(). It isn’t used appropriately here because we revert the data back to untidy format. &gt; spread(df, key=fate, value=number) # A tibble: 2 x 3 sex perished survived &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 female 126 344 2 male 1364 367 7.4.5 Tidy with spread() Median cost of home and median income per city are two variables included in a single column. This means we need to use spread(). &gt; df # A tibble: 4 x 3 city median_value dollars &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Boston home 527300 2 Boston income 71738 3 Raleigh home 215700 4 Raleigh income 65778 &gt; spread(df, key=median_value, value=dollars) # A tibble: 2 x 3 city home income &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Boston 527300 71738 2 Raleigh 215700 65778 7.5 Reshaping Data 7.5.1 Wide vs. Long Format Tidy data are in “wide format” in that they have a column for each variable and there is one observed unit per row. However, sometimes it’s useful to transform to “long format.” The simplest long format data have two columns. The first column contains the variable names and the second colum contains the values for the variables. There are “wider” long format data that have additional columns that identify connections between observations. Wide format data is useful for some analyses and long format for others. 7.5.2 reshape2 Package The reshape2 package has three important functions: melt, dcast, and acast. It allows one to move between wide and long tidy data formats. &gt; library(&quot;reshape2&quot;) &gt; library(&quot;datasets&quot;) &gt; data(airquality, package=&quot;datasets&quot;) &gt; names(airquality) [1] &quot;Ozone&quot; &quot;Solar.R&quot; &quot;Wind&quot; &quot;Temp&quot; &quot;Month&quot; &quot;Day&quot; &gt; dim(airquality) [1] 153 6 &gt; airquality &lt;- as_tibble(airquality) 7.5.3 Air Quality Data Set &gt; head(airquality) # A tibble: 6 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 41 190 7.4 67 5 1 2 36 118 8 72 5 2 3 12 149 12.6 74 5 3 4 18 313 11.5 62 5 4 5 NA NA 14.3 56 5 5 6 28 NA 14.9 66 5 6 &gt; tail(airquality) # A tibble: 6 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 14 20 16.6 63 9 25 2 30 193 6.9 70 9 26 3 NA 145 13.2 77 9 27 4 14 191 14.3 75 9 28 5 18 131 8 76 9 29 6 20 223 11.5 68 9 30 7.5.4 Melt Melting can be thought of as melting a piece of solid metal (wide data), so it drips into long format. &gt; aql &lt;- melt(airquality) No id variables; using all as measure variables &gt; head(aql) variable value 1 Ozone 41 2 Ozone 36 3 Ozone 12 4 Ozone 18 5 Ozone NA 6 Ozone 28 &gt; tail(aql) variable value 913 Day 25 914 Day 26 915 Day 27 916 Day 28 917 Day 29 918 Day 30 7.5.5 Guided Melt In the previous example, we lose the fact that a set of measurements occurred on a particular day and month, so we can do a guided melt to keep this information. &gt; aql &lt;- melt(airquality, id.vars = c(&quot;Month&quot;, &quot;Day&quot;)) &gt; head(aql) Month Day variable value 1 5 1 Ozone 41 2 5 2 Ozone 36 3 5 3 Ozone 12 4 5 4 Ozone 18 5 5 5 Ozone NA 6 5 6 Ozone 28 &gt; tail(aql) Month Day variable value 607 9 25 Temp 63 608 9 26 Temp 70 609 9 27 Temp 77 610 9 28 Temp 75 611 9 29 Temp 76 612 9 30 Temp 68 7.5.6 Casting Casting allows us to go from long format to wide format data. It can be visualized as pouring molten metal (long format) into a cast to create a solid piece of metal (wide format). Casting is more difficult because choices have to be made to determine how the wide format will be organized. It often takes some thought and experimentation for new users. Let’s do an example with dcast, which is casting for data frames. 7.5.7 dcast() &gt; aqw &lt;- dcast(aql, Month + Day ~ variable) &gt; head(aqw) Month Day Ozone Solar.R Wind Temp 1 5 1 41 190 7.4 67 2 5 2 36 118 8.0 72 3 5 3 12 149 12.6 74 4 5 4 18 313 11.5 62 5 5 5 NA NA 14.3 56 6 5 6 28 NA 14.9 66 &gt; tail(aqw) Month Day Ozone Solar.R Wind Temp 148 9 25 14 20 16.6 63 149 9 26 30 193 6.9 70 150 9 27 NA 145 13.2 77 151 9 28 14 191 14.3 75 152 9 29 18 131 8.0 76 153 9 30 20 223 11.5 68 "],
["transforming-data.html", "8 Transforming Data 8.1 dplyr Package 8.2 Grammar of dplyr 8.3 Baby Names Data Set 8.4 %&gt;% Operator 8.5 filter() 8.6 arrange() 8.7 rename() 8.8 select() 8.9 mutate() 8.10 distinct() 8.11 summarize() 8.12 group_by() 8.13 Chaining Verbs Together", " 8 Transforming Data 8.1 dplyr Package dplyr is a package with the following description: A fast, consistent tool for working with data frame like objects, both in memory and out of memory. This package offers a “grammar” for manipulating data frames. Everything that dplyr does can also be done using basic R commands – however, it tends to be much faster and easier to use dplyr. 8.2 Grammar of dplyr Verbs: filter: extract a subset of rows from a data frame based on logical conditions arrange: reorder rows of a data frame rename: rename variables in a data frame select: return a subset of the columns of a data frame, using a flexible notation mutate: add new variables/columns or transform existing variables distinct: returns only the unique values in a table summarize: generate summary statistics of different variables in the data frame, possibly within strata group_by: breaks down a dataset into specified groups of rows Partially based on R Programming for Data Science 8.3 Baby Names Data Set &gt; library(&quot;dplyr&quot;, verbose=FALSE) &gt; library(&quot;babynames&quot;) &gt; ls() character(0) &gt; babynames &lt;- as_tibble(babynames::babynames) &gt; ls() [1] &quot;babynames&quot; The babynames Object &gt; class(babynames) [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; &gt; dim(babynames) [1] 1924665 5 &gt; babynames # A tibble: 1,924,665 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 2 1880 F Anna 2604 0.0267 3 1880 F Emma 2003 0.0205 4 1880 F Elizabeth 1939 0.0199 5 1880 F Minnie 1746 0.0179 6 1880 F Margaret 1578 0.0162 7 1880 F Ida 1472 0.0151 8 1880 F Alice 1414 0.0145 9 1880 F Bertha 1320 0.0135 10 1880 F Sarah 1288 0.0132 # … with 1,924,655 more rows Peek at the Data &gt; set.seed(201) &gt; sample_n(babynames, 10) # A tibble: 10 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1994 M Kael 16 0.00000785 2 1989 F Nafeesah 6 0.00000301 3 2017 M Yireh 5 0.00000255 4 1976 M Marrio 11 0.00000674 5 2008 M Kerolos 9 0.00000413 6 1993 F Claire 1895 0.000961 7 2002 F Rubit 5 0.00000253 8 2006 F Kaija 26 0.0000124 9 1990 F Leshae 7 0.00000341 10 1940 F Vernell 146 0.000124 &gt; ## try also sample_frac(babynames, 6e-6) 8.4 %&gt;% Operator Originally from R package magrittr. Provides a mechanism for chaining commands with a forward-pipe operator, %&gt;%. &gt; x &lt;- 1:10 &gt; &gt; x %&gt;% log(base=10) %&gt;% sum() [1] 6.559763 &gt; &gt; sum(log(x,base=10)) [1] 6.559763 &gt; babynames %&gt;% sample_n(5) # A tibble: 5 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1974 F Greer 14 0.00000894 2 1933 M Porter 68 0.0000667 3 2004 M Jacobo 69 0.0000327 4 1987 F Morgaine 7 0.00000374 5 1947 F Bonnye 22 0.0000121 8.5 filter() &gt; filter(babynames, year==1880, sex==&quot;F&quot;) # A tibble: 942 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 2 1880 F Anna 2604 0.0267 3 1880 F Emma 2003 0.0205 4 1880 F Elizabeth 1939 0.0199 5 1880 F Minnie 1746 0.0179 6 1880 F Margaret 1578 0.0162 7 1880 F Ida 1472 0.0151 8 1880 F Alice 1414 0.0145 9 1880 F Bertha 1320 0.0135 10 1880 F Sarah 1288 0.0132 # … with 932 more rows &gt; ## same as filter(babynames, year==1880 &amp; sex==&quot;F&quot;) &gt; filter(babynames, year==1880, sex==&quot;F&quot;, n &gt; 5000) # A tibble: 1 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 8.6 arrange() &gt; arrange(babynames, name, year, sex) # A tibble: 1,924,665 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 2007 M Aaban 5 0.00000226 2 2009 M Aaban 6 0.00000283 3 2010 M Aaban 9 0.00000439 4 2011 M Aaban 11 0.00000542 5 2012 M Aaban 11 0.00000543 6 2013 M Aaban 14 0.00000694 7 2014 M Aaban 16 0.00000783 8 2015 M Aaban 15 0.00000736 9 2016 M Aaban 9 0.00000446 10 2017 M Aaban 11 0.0000056 # … with 1,924,655 more rows &gt; arrange(babynames, desc(name), desc(year), sex) # A tibble: 1,924,665 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 2010 M Zzyzx 5 0.00000244 2 2014 M Zyyon 6 0.00000293 3 2010 F Zyyanna 6 0.00000306 4 2015 M Zyvon 7 0.00000343 5 2009 M Zyvion 5 0.00000236 6 2017 F Zyva 9 0.0000048 7 2016 F Zyva 8 0.00000415 8 2015 M Zyus 5 0.00000245 9 2010 M Zytavious 6 0.00000292 10 2009 M Zytavious 7 0.0000033 # … with 1,924,655 more rows 8.7 rename() &gt; rename(babynames, number=n) # A tibble: 1,924,665 x 5 year sex name number prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 2 1880 F Anna 2604 0.0267 3 1880 F Emma 2003 0.0205 4 1880 F Elizabeth 1939 0.0199 5 1880 F Minnie 1746 0.0179 6 1880 F Margaret 1578 0.0162 7 1880 F Ida 1472 0.0151 8 1880 F Alice 1414 0.0145 9 1880 F Bertha 1320 0.0135 10 1880 F Sarah 1288 0.0132 # … with 1,924,655 more rows 8.8 select() &gt; select(babynames, sex, name, n) # A tibble: 1,924,665 x 3 sex name n &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 F Mary 7065 2 F Anna 2604 3 F Emma 2003 4 F Elizabeth 1939 5 F Minnie 1746 6 F Margaret 1578 7 F Ida 1472 8 F Alice 1414 9 F Bertha 1320 10 F Sarah 1288 # … with 1,924,655 more rows &gt; ## same as select(babynames, sex:n) Renaming with select(): &gt; select(babynames, sex, name, number=n) # A tibble: 1,924,665 x 3 sex name number &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 F Mary 7065 2 F Anna 2604 3 F Emma 2003 4 F Elizabeth 1939 5 F Minnie 1746 6 F Margaret 1578 7 F Ida 1472 8 F Alice 1414 9 F Bertha 1320 10 F Sarah 1288 # … with 1,924,655 more rows 8.9 mutate() &gt; mutate(babynames, total_by_year=round(n/prop)) # A tibble: 1,924,665 x 6 year sex name n prop total_by_year &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 97605 2 1880 F Anna 2604 0.0267 97605 3 1880 F Emma 2003 0.0205 97605 4 1880 F Elizabeth 1939 0.0199 97605 5 1880 F Minnie 1746 0.0179 97605 6 1880 F Margaret 1578 0.0162 97605 7 1880 F Ida 1472 0.0151 97605 8 1880 F Alice 1414 0.0145 97605 9 1880 F Bertha 1320 0.0135 97605 10 1880 F Sarah 1288 0.0132 97605 # … with 1,924,655 more rows &gt; ## see also transmutate 8.10 distinct() Let’s put a few things together now adding the function distinct()… &gt; babynames %&gt;% mutate(total_by_year=round(n/prop)) %&gt;% + select(sex, year, total_by_year) %&gt;% distinct() # A tibble: 36,099 x 3 sex year total_by_year &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 F 1880 97605 2 F 1880 97604 3 F 1880 97606 4 F 1880 97603 5 F 1880 97607 6 F 1880 97602 7 F 1880 97609 8 F 1880 97599 9 M 1880 118400 10 M 1880 118399 # … with 36,089 more rows 8.11 summarize() &gt; summarize(babynames, mean_n = mean(n), median_n = median(n), + number_sex = n_distinct(sex), + distinct_names = n_distinct(name)) # A tibble: 1 x 4 mean_n median_n number_sex distinct_names &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 181. 12 2 97310 8.12 group_by() &gt; babynames %&gt;% group_by(year, sex) # A tibble: 1,924,665 x 5 # Groups: year, sex [276] year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 F Mary 7065 0.0724 2 1880 F Anna 2604 0.0267 3 1880 F Emma 2003 0.0205 4 1880 F Elizabeth 1939 0.0199 5 1880 F Minnie 1746 0.0179 6 1880 F Margaret 1578 0.0162 7 1880 F Ida 1472 0.0151 8 1880 F Alice 1414 0.0145 9 1880 F Bertha 1320 0.0135 10 1880 F Sarah 1288 0.0132 # … with 1,924,655 more rows 8.13 Chaining Verbs Together No. Individuals by Year and Sex &gt; babynames %&gt;% group_by(year, sex) %&gt;% + summarize(total_by_year=sum(n)) # A tibble: 276 x 3 # Groups: year [138] year sex total_by_year &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; 1 1880 F 90993 2 1880 M 110491 3 1881 F 91953 4 1881 M 100743 5 1882 F 107847 6 1882 M 113686 7 1883 F 112319 8 1883 M 104627 9 1884 F 129020 10 1884 M 114442 # … with 266 more rows How Many Distinct Names? &gt; babynames %&gt;% group_by(sex) %&gt;% + summarize(mean_n = mean(n), + distinct_names_sex = n_distinct(name)) # A tibble: 2 x 3 sex mean_n distinct_names_sex &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 F 151. 67046 2 M 223. 40927 Most Popular Names by Year &gt; top_names &lt;- babynames %&gt;% group_by(year, sex) %&gt;% + summarize(top_name = name[which.max(n)]) &gt; &gt; head(top_names) # A tibble: 6 x 3 # Groups: year [3] year sex top_name &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1880 F Mary 2 1880 M John 3 1881 F Mary 4 1881 M John 5 1882 F Mary 6 1882 M John Most Popular Names in Recent Years &gt; tail(top_names, n=10) # A tibble: 10 x 3 # Groups: year [5] year sex top_name &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 F Sophia 2 2013 M Noah 3 2014 F Emma 4 2014 M Noah 5 2015 F Emma 6 2015 M Noah 7 2016 F Emma 8 2016 M Noah 9 2017 F Emma 10 2017 M Liam Most Popular Female Names in the 1990s &gt; top_names %&gt;% filter(year &gt;= 1990 &amp; year &lt; 2000, sex==&quot;F&quot;) # A tibble: 10 x 3 # Groups: year [10] year sex top_name &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1990 F Jessica 2 1991 F Ashley 3 1992 F Ashley 4 1993 F Jessica 5 1994 F Jessica 6 1995 F Jessica 7 1996 F Emily 8 1997 F Emily 9 1998 F Emily 10 1999 F Emily Most Popular Male Names in the 1990s &gt; top_names %&gt;% filter(year &gt;= 1990 &amp; year &lt; 2000, sex==&quot;M&quot;) # A tibble: 10 x 3 # Groups: year [10] year sex top_name &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1990 M Michael 2 1991 M Michael 3 1992 M Michael 4 1993 M Michael 5 1994 M Michael 6 1995 M Michael 7 1996 M Michael 8 1997 M Michael 9 1998 M Michael 10 1999 M Jacob Analyzing the name ‘John’ &gt; john &lt;- babynames %&gt;% filter(sex==&quot;M&quot;, name==&quot;John&quot;) &gt; plot(john$year, john$prop, type=&quot;l&quot;) Analyzing the name ‘Bella’ &gt; bella &lt;- babynames %&gt;% filter(sex==&quot;F&quot;, name==&quot;Bella&quot;) &gt; plot(bella$year, bella$prop, type=&quot;l&quot;) "],
["relational-data.html", "9 Relational Data 9.1 Multiple Data Sets 9.2 Toy Example 9.3 Verbs 9.4 inner_join() 9.5 left_join() 9.6 right_join() 9.7 full_join() 9.8 anti_join() 9.9 semi_join() 9.10 Repeated Key Values 9.11 Set Operations", " 9 Relational Data 9.1 Multiple Data Sets In many data analyses you will have multiple tables of related data that must be combined in order to carry out your analysis. The dplyr package includes a number of tools to facilitate this. 9.2 Toy Example Here are two data frames that are related through a common variable called key. &gt; x &lt;- tibble(key = c(1, 2, 3), x_val = c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;)) &gt; y &lt;- tibble(key = c(1, 2, 4), y_val = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y4&quot;)) &gt; x # A tibble: 3 x 2 key x_val &lt;dbl&gt; &lt;chr&gt; 1 1 x1 2 2 x2 3 3 x3 &gt; y # A tibble: 3 x 2 key y_val &lt;dbl&gt; &lt;chr&gt; 1 1 y1 2 2 y2 3 4 y4 9.3 Verbs To work with relational data you need verbs that work with pairs of tables. There are three families of verbs designed to work with relational data. Mutating joins add new variables to one data frame from matching observations in another. Filtering joins filter observations from one data frame based on whether or not they match an observation in the other table. Set operations treat observations as if they were set elements. From R for Data Science 9.4 inner_join() An inner-join matches pairs of observations when their keys are equal. &gt; inner_join(x, y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 2 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 9.5 left_join() A left-join keeps all observations in the first argument, x. &gt; left_join(x, y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 3 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 3 x3 &lt;NA&gt; &gt; x %&gt;% left_join(y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 3 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 3 x3 &lt;NA&gt; 9.6 right_join() A right-join keeps all observations in the second argument, y. &gt; right_join(x, y) Joining, by = &quot;key&quot; # A tibble: 3 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 4 &lt;NA&gt; y4 9.7 full_join() A full-join keeps all observations in either argument, x or y. &gt; full_join(x, y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 4 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 3 x3 &lt;NA&gt; 4 4 &lt;NA&gt; y4 9.8 anti_join() An anti-join removes all observations in the first argument, x, that appear in the second argument, y. &gt; anti_join(x, y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 1 x 2 key x_val &lt;dbl&gt; &lt;chr&gt; 1 3 x3 9.9 semi_join() A semi-join keeps all observations in the first argument, x, that have a match in the second argument, y. &gt; semi_join(x, y, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 2 x 2 key x_val &lt;dbl&gt; &lt;chr&gt; 1 1 x1 2 2 x2 9.10 Repeated Key Values When one of the two data frames has repeated key values, the observations are repeated in the other data frame. &gt; y2 # A tibble: 4 x 2 key y_val &lt;dbl&gt; &lt;chr&gt; 1 1 y1 2 2 y2a 3 2 y2b 4 4 y4 &gt; x %&gt;% left_join(y2, key=&quot;key&quot;) Joining, by = &quot;key&quot; # A tibble: 4 x 3 key x_val y_val &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2a 3 2 x2 y2b 4 3 x3 &lt;NA&gt; 9.11 Set Operations One can perform traditional set operations on the rows of data frames. intersect(x, y): return only observations in both x and y union(x, y): return unique observations in x and y setdiff(x, y): return observations in x, but not in y From R for Data Science Example setdiff() &gt; df1 # A tibble: 2 x 2 x y &lt;dbl&gt; &lt;dbl&gt; 1 1 1 2 2 1 &gt; df2 # A tibble: 2 x 2 x y &lt;dbl&gt; &lt;dbl&gt; 1 1 1 2 1 2 &gt; setdiff(df1, df2) # A tibble: 1 x 2 x y &lt;dbl&gt; &lt;dbl&gt; 1 2 1 "],
["case-study-in-data-wrangling.html", "10 Case Study in Data Wrangling 10.1 Yeast Genomics", " 10 Case Study in Data Wrangling 10.1 Yeast Genomics Smith and Kruglyak (2008) is a study that measured 2820 genotypes in 109 yeast F1 segregants from a cross between parental lines BY and RM. They also measured gene expression on 4482 genes in each of these segregants when growing in two different Carbon sources, glucose and ethanol. 10.1.1 Load Data The data was distributed as a collection of matrices in R. &gt; rm(list=ls()) &gt; load(&quot;./data/smith_kruglyak.RData&quot;) &gt; ls() [1] &quot;exp.e&quot; &quot;exp.g&quot; &quot;exp.pos&quot; &quot;marker&quot; &quot;marker.pos&quot; &gt; eapply(env=.GlobalEnv, dim) $exp.e [1] 4482 109 $exp.g [1] 4482 109 $marker [1] 2820 109 $exp.pos [1] 4482 3 $marker.pos [1] 2820 2 10.1.2 Gene Expression Matrices &gt; exp.g %&gt;% cbind(rownames(exp.g), .) %&gt;% as_tibble() %&gt;% + print() Warning: `as_tibble.matrix()` requires a matrix with column names or a `.name_repair` argument. Using compatibility `.name_repair`. This warning is displayed once per session. # A tibble: 4,482 x 110 V1 X100g.20_4_c.gl… X101g.21_1_d.gl… X102g.21_2_d.gl… &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 YJR1… 0.22 0.18 0.05 2 YPL2… -0.29 -0.2 -0.19 3 YDR5… 0.72 0.04 0.26 4 YDR2… 0.23 0.31 0.12 5 YHR0… 0.4 -0.04 0.36 6 YFR0… -0.36 0.35 -0.26 7 YPL1… 0.23 -0.21 -0.25 8 YDR0… -0.09 0.57 0.24 9 YLR3… -0.23 0.13 -0.17 10 YCR0… -0.25 -0.98 -0.3 # … with 4,472 more rows, and 106 more variables: # X103g.21_3_d.glucose &lt;chr&gt;, X104g.21_4_d.glucose &lt;chr&gt;, # X105g.21_5_c.glucose &lt;chr&gt;, X106g.22_2_d.glucose &lt;chr&gt;, # X107g.22_3_b.glucose &lt;chr&gt;, X109g.22_5_d.glucose &lt;chr&gt;, # X10g.2_5_d.glucose &lt;chr&gt;, X110g.23_3_d.glucose &lt;chr&gt;, # X111g.23_5_d.glucose &lt;chr&gt;, X112g.24_1_d.glucose &lt;chr&gt;, # X113g.25_1_d.glucose &lt;chr&gt;, X114g.25_3_d.glucose &lt;chr&gt;, # X115g.25_4_d.glucose &lt;chr&gt;, X116g.26_1_d.glucose &lt;chr&gt;, # X117g.26_2_d.glucose &lt;chr&gt;, X11g.2_6_d.glucose &lt;chr&gt;, # X12g.2_7_a.glucose &lt;chr&gt;, X13g.3_1_d.glucose &lt;chr&gt;, # X15g.3_3_d.glucose &lt;chr&gt;, X16g.3_4_d.glucose &lt;chr&gt;, # X17g.3_5_d.glucose &lt;chr&gt;, X18g.4_1_c.glucose &lt;chr&gt;, # X1g.1_1_d.glucose &lt;chr&gt;, X20g.4_3_d.glucose &lt;chr&gt;, # X21g.4_4_d.glucose &lt;chr&gt;, X22g.5_1_d.glucose &lt;chr&gt;, # X23g.5_2_d.glucose &lt;chr&gt;, X24g.5_3_d.glucose &lt;chr&gt;, # X25g.5_4_d.glucose &lt;chr&gt;, X26g.5_5_d.glucose &lt;chr&gt;, # X27g.6_1_d.glucose &lt;chr&gt;, X28g.6_2_b.glucose &lt;chr&gt;, # X29g.6_3_c.glucose &lt;chr&gt;, X30g.6_4_d.glucose &lt;chr&gt;, # X31g.6_5_d.glucose &lt;chr&gt;, X32g.6_6_d.glucose &lt;chr&gt;, # X33g.6_7_d.glucose &lt;chr&gt;, X34g.7_1_d.glucose &lt;chr&gt;, # X35g.7_2_c.glucose &lt;chr&gt;, X36g.7_3_d.glucose &lt;chr&gt;, # X37g.7_4_c.glucose &lt;chr&gt;, X38g.7_5_d.glucose &lt;chr&gt;, # X39g.7_6_c.glucose &lt;chr&gt;, X3g.1_3_d.glucose &lt;chr&gt;, # X40g.7_7_c.glucose &lt;chr&gt;, X41g.7_8_d.glucose &lt;chr&gt;, # X42g.8_1_a.glucose &lt;chr&gt;, X43g.8_2_d.glucose &lt;chr&gt;, # X44g.8_3_a.glucose &lt;chr&gt;, X45g.8_4_c.glucose &lt;chr&gt;, # X46g.8_5_b.glucose &lt;chr&gt;, X47g.8_6_c.glucose &lt;chr&gt;, # X48g.8_7_b.glucose &lt;chr&gt;, X49g.9_1_d.glucose &lt;chr&gt;, # X4g.1_4_d.glucose &lt;chr&gt;, X50g.9_2_d.glucose &lt;chr&gt;, # X51g.9_3_d.glucose &lt;chr&gt;, X52g.9_4_d.glucose &lt;chr&gt;, # X53g.9_5_d.glucose &lt;chr&gt;, X54g.9_6_d.glucose &lt;chr&gt;, # X55g.9_7_d.glucose &lt;chr&gt;, X56g.10_1_c.glucose &lt;chr&gt;, # X57g.10_2_d.glucose &lt;chr&gt;, X58g.10_3_c.glucose &lt;chr&gt;, # X59g.10_4_d.glucose &lt;chr&gt;, X5g.1_5_c.glucose &lt;chr&gt;, # X60g.11_1_a.glucose &lt;chr&gt;, X61g.11_2_d.glucose &lt;chr&gt;, # X62g.11_3_b.glucose &lt;chr&gt;, X63g.12_1_d.glucose &lt;chr&gt;, # X64g.12_2_b.glucose &lt;chr&gt;, X65g.13_1_a.glucose &lt;chr&gt;, # X66g.13_2_c.glucose &lt;chr&gt;, X67g.13_3_b.glucose &lt;chr&gt;, # X68g.13_4_a.glucose &lt;chr&gt;, X69g.13_5_c.glucose &lt;chr&gt;, # X70g.14_1_b.glucose &lt;chr&gt;, X71g.14_2_c.glucose &lt;chr&gt;, # X73g.14_4_a.glucose &lt;chr&gt;, X74g.14_5_b.glucose &lt;chr&gt;, # X75g.14_6_d.glucose &lt;chr&gt;, X76g.14_7_c.glucose &lt;chr&gt;, # X77g.15_2_d.glucose &lt;chr&gt;, X78g.15_3_b.glucose &lt;chr&gt;, # X79g.15_4_d.glucose &lt;chr&gt;, X7g.2_2_d.glucose &lt;chr&gt;, # X80g.15_5_b.glucose &lt;chr&gt;, X82g.16_1_d.glucose &lt;chr&gt;, # X83g.17_1_a.glucose &lt;chr&gt;, X84g.17_2_d.glucose &lt;chr&gt;, # X85g.17_4_a.glucose &lt;chr&gt;, X86g.17_5_b.glucose &lt;chr&gt;, # X87g.18_1_d.glucose &lt;chr&gt;, X88g.18_2_d.glucose &lt;chr&gt;, # X89g.18_3_d.glucose &lt;chr&gt;, X8g.2_3_d.glucose &lt;chr&gt;, # X90g.18_4_c.glucose &lt;chr&gt;, X92g.19_1_c.glucose &lt;chr&gt;, # X93g.19_2_c.glucose &lt;chr&gt;, X94g.19_3_c.glucose &lt;chr&gt;, … 10.1.3 Gene Position Matrix &gt; exp.pos %&gt;% cbind(rownames(exp.pos), .) %&gt;% as_tibble() %&gt;% + print() # A tibble: 4,482 x 4 V1 Chromsome Start_coord End_coord &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 YJR107W 10 627333 628319 2 YPL270W 16 30482 32803 3 YDR518W 4 1478600 1480153 4 YDR233C 4 930353 929466 5 YHR098C 8 301937 299148 6 YFR029W 6 210925 212961 7 YPL198W 16 173151 174701 8 YDR001C 4 452472 450217 9 YLR394W 12 907950 909398 10 YCR079W 3 252842 254170 # … with 4,472 more rows 10.1.4 Row Names The gene names are contained in the row names. &gt; head(rownames(exp.g)) [1] &quot;YJR107W&quot; &quot;YPL270W&quot; &quot;YDR518W&quot; &quot;YDR233C&quot; &quot;YHR098C&quot; &quot;YFR029W&quot; &gt; head(rownames(exp.e)) [1] &quot;YJR107W&quot; &quot;YPL270W&quot; &quot;YDR518W&quot; &quot;YDR233C&quot; &quot;YHR098C&quot; &quot;YFR029W&quot; &gt; head(rownames(exp.pos)) [1] &quot;YJR107W&quot; &quot;YPL270W&quot; &quot;YDR518W&quot; &quot;YDR233C&quot; &quot;YHR098C&quot; &quot;YFR029W&quot; &gt; all.equal(rownames(exp.g), rownames(exp.e)) [1] TRUE &gt; all.equal(rownames(exp.g), rownames(exp.pos)) [1] TRUE 10.1.5 Unify Column Names The segregants are column names, and they are inconsistent across matrices. &gt; head(colnames(exp.g)) [1] &quot;X100g.20_4_c.glucose&quot; &quot;X101g.21_1_d.glucose&quot; &quot;X102g.21_2_d.glucose&quot; [4] &quot;X103g.21_3_d.glucose&quot; &quot;X104g.21_4_d.glucose&quot; &quot;X105g.21_5_c.glucose&quot; &gt; head(colnames(marker)) [1] &quot;20_4_c&quot; &quot;21_1_d&quot; &quot;21_2_d&quot; &quot;21_3_d&quot; &quot;21_4_d&quot; &quot;21_5_c&quot; &gt; &gt; ##fix column names with gsub &gt; colnames(exp.g) %&lt;&gt;% strsplit(split=&quot;.&quot;, fixed=TRUE) %&gt;% + lapply(function(x) {x[2]}) &gt; colnames(exp.e) %&lt;&gt;% strsplit(split=&quot;.&quot;, fixed=TRUE) %&gt;% + lapply(function(x) {x[2]}) &gt; head(colnames(exp.g)) [1] &quot;20_4_c&quot; &quot;21_1_d&quot; &quot;21_2_d&quot; &quot;21_3_d&quot; &quot;21_4_d&quot; &quot;21_5_c&quot; 10.1.6 Gene Positions Let’s first pull out rownames of exp.pos and make them a column in the data frame. &gt; gene_pos &lt;- exp.pos %&gt;% as_tibble() %&gt;% + mutate(gene = rownames(exp.pos)) %&gt;% + dplyr::select(gene, chr = Chromsome, start = Start_coord, + end = End_coord) &gt; print(gene_pos, n=7) # A tibble: 4,482 x 4 gene chr start end &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 YJR107W 10 627333 628319 2 YPL270W 16 30482 32803 3 YDR518W 4 1478600 1480153 4 YDR233C 4 930353 929466 5 YHR098C 8 301937 299148 6 YFR029W 6 210925 212961 7 YPL198W 16 173151 174701 # … with 4,475 more rows 10.1.7 Tidy Each Expression Matrix We melt the expression matrices and bind them together into one big tidy data frame. &gt; exp_g &lt;- melt(exp.g) %&gt;% as_tibble() %&gt;% + dplyr::select(gene = Var1, segregant = Var2, + expression = value) %&gt;% + mutate(condition = &quot;glucose&quot;) &gt; exp_e &lt;- melt(exp.e) %&gt;% as_tibble() %&gt;% + dplyr::select(gene = Var1, segregant = Var2, + expression = value) %&gt;% + mutate(condition = &quot;ethanol&quot;) &gt; print(exp_e, n=4) # A tibble: 488,538 x 4 gene segregant expression condition &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; 1 YJR107W 20_4_c 0.06 ethanol 2 YPL270W 20_4_c -0.13 ethanol 3 YDR518W 20_4_c -0.94 ethanol 4 YDR233C 20_4_c 0.04 ethanol # … with 4.885e+05 more rows 10.1.8 Combine Into Single Data Frame Combine gene expression data from two conditions into a single data frame. &gt; exp_all &lt;- bind_rows(exp_g, exp_e) &gt; sample_n(exp_all, size=10) # A tibble: 10 x 4 gene segregant expression condition &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; 1 YAL039C 5_4_d 0.290 glucose 2 YFL034W 13_1_a -0.08 glucose 3 YHR138C 17_5_b -0.49 glucose 4 YOR122C 8_3_a 0.15 glucose 5 YOR330C 5_1_d -0.404 ethanol 6 YNL246W 9_4_d 0.36 glucose 7 YPL146C 13_5_c -0.06 glucose 8 YLR401C 9_5_d -0.61 ethanol 9 YNL177C 22_3_b -0.1 glucose 10 YGR125W 11_2_d -0.05 ethanol 10.1.9 Join Gene Positions Now we want to join the gene positions with the expression data. &gt; exp_all &lt;- exp_all %&gt;% + mutate(gene = as.character(gene), + segregant = as.character(segregant)) &gt; sk_tidy &lt;- exp_all %&gt;% + left_join(gene_pos, by = &quot;gene&quot;) &gt; sample_n(sk_tidy, size=7) # A tibble: 7 x 7 gene segregant expression condition chr start end &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 YGL098W 14_4_a 0.26 ethanol 7 317345 318082 2 YGR058W 14_5_b -0.23 glucose 7 606140 607147 3 YOR217W 5_5_d -0.37 ethanol 15 749302 751887 4 YIL057C 9_1_d -3.99 glucose 9 248393 247899 5 YMR316W 2_6_d 0.44 glucose 13 904823 905833 6 YCL035C 14_4_a 0.91 glucose 3 61173 60841 7 YLR020C 2_3_d 0.04 ethanol 12 183404 181788 10.1.10 Apply dplyr Functions Now that we have the data made tidy in the data frame sk_tidy, let’s apply some dplyr operations… Does each gene have the same number of observations? &gt; sk_tidy %&gt;% group_by(gene) %&gt;% + summarize(value = n()) %&gt;% + summary() gene value Length:4478 Min. :218.0 Class :character 1st Qu.:218.0 Mode :character Median :218.0 Mean :218.6 3rd Qu.:218.0 Max. :872.0 No, so let’s see which genes have more than one set of observations. &gt; sk_tidy %&gt;% group_by(gene) %&gt;% + summarize(value = n()) %&gt;% + filter(value &gt; median(value)) # A tibble: 4 x 2 gene value &lt;chr&gt; &lt;int&gt; 1 YFR024C-A 872 2 YJL012C 872 3 YKL198C 872 4 YPR089W 872 Let’s remove replicated measurements for these genes. &gt; sk_tidy %&lt;&gt;% distinct(gene, segregant, condition, + .keep_all = TRUE) &gt; &gt; sk_tidy %&gt;% group_by(gene) %&gt;% + summarize(value = n()) %&gt;% + summary() gene value Length:4478 Min. :218 Class :character 1st Qu.:218 Mode :character Median :218 Mean :218 3rd Qu.:218 Max. :218 As an exercise, think about how you would use dplyr to replace the replicated gene expression values with a single averaged expression value for these genes. Get the mean and standard deviation expression per chromosome. &gt; sk_tidy %&gt;% + group_by(chr) %&gt;% + summarize(mean = mean(expression), sd=sd(expression)) # A tibble: 16 x 3 chr mean sd &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 -0.0762 0.826 2 2 -0.0447 0.632 3 3 -0.0230 0.682 4 4 -0.0233 0.537 5 5 -0.0579 0.610 6 6 -0.0772 0.660 7 7 -0.0441 0.617 8 8 -0.0474 0.638 9 9 -0.0430 0.614 10 10 -0.0299 0.570 11 11 -0.0396 0.613 12 12 -0.0515 0.643 13 13 -0.0265 0.584 14 14 -0.0294 0.642 15 15 -0.0130 0.554 16 16 -0.0368 0.604 Get the mean and standard deviation expression per chromosome in each condition. &gt; sk_tidy %&gt;% + group_by(chr, condition) %&gt;% + summarize(mean = mean(expression), sd=sd(expression)) # A tibble: 32 x 4 # Groups: chr [16] chr condition mean sd &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 ethanol 0.0260 0.480 2 1 glucose -0.178 1.05 3 2 ethanol 0.0132 0.479 4 2 glucose -0.103 0.750 5 3 ethanol 0.000164 0.536 6 3 glucose -0.0461 0.800 7 4 ethanol 0.00187 0.482 8 4 glucose -0.0484 0.586 9 5 ethanol -0.0297 0.479 10 5 glucose -0.0862 0.716 # … with 22 more rows Count the number of genes per chromosome. &gt; sk_tidy %&gt;% + filter(condition == &quot;glucose&quot;, segregant == &quot;20_4_c&quot;) %&gt;% + group_by(chr) %&gt;% + summarize(num.genes = n()) # A tibble: 16 x 2 chr num.genes &lt;int&gt; &lt;int&gt; 1 1 60 2 2 298 3 3 125 4 4 629 5 5 207 6 6 79 7 7 395 8 8 209 9 9 152 10 10 256 11 11 241 12 12 387 13 13 367 14 14 319 15 15 388 16 16 366 Filter for the first gene on every chromosome. &gt; sk_tidy %&gt;% + filter(condition == &quot;glucose&quot;, segregant == &quot;20_4_c&quot;) %&gt;% + group_by(chr) %&gt;% + filter(start == min(start)) # A tibble: 16 x 7 # Groups: chr [16] gene segregant expression condition chr start end &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 YHL040C 20_4_c -2.79 glucose 8 20968 19085 2 YNL334C 20_4_c -0.9 glucose 14 12876 12208 3 YOL157C 20_4_c -1.06 glucose 15 24293 22524 4 YKL222C 20_4_c 0.09 glucose 11 5621 3504 5 YIL168W 20_4_c -1.14 glucose 9 29032 29415 6 YJL213W 20_4_c 0.84 glucose 10 32163 33158 7 YPL272C 20_4_c -0.18 glucose 16 28164 26611 8 YLL063C 20_4_c -0.66 glucose 12 16072 14648 9 YFL048C 20_4_c -0.09 glucose 6 40180 38843 10 YML132W 20_4_c -0.21 glucose 13 7244 8383 11 YGL261C 20_4_c -0.14 glucose 7 6652 6290 12 YBL107C 20_4_c 0.290 glucose 2 10551 9961 13 YDL248W 20_4_c -0.68 glucose 4 1802 2953 14 YEL073C 20_4_c -0.02 glucose 5 7553 7230 15 YAL062W 20_4_c -5.64 glucose 1 31568 32941 16 YCL068C 20_4_c 0.47 glucose 3 12285 11503 To plot expression in glucose versus ethanol we first need to use dcast(). &gt; sk_tidy %&gt;% dcast(gene + segregant ~ condition, + value.var = &quot;expression&quot;) %&gt;% + as_tibble() # A tibble: 488,102 x 4 gene segregant ethanol glucose &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 YAL002W 1_1_d 0.37 -0.01 2 YAL002W 1_3_d 0.23 0.03 3 YAL002W 1_4_d 0.08 0.07 4 YAL002W 1_5_c -0.12 0.13 5 YAL002W 10_1_c 0.12 -0.1 6 YAL002W 10_2_d 0.1 -0.2 7 YAL002W 10_3_c 0.07 -0.15 8 YAL002W 10_4_d 0.06 -0.04 9 YAL002W 11_1_a 0.07 -0.07 10 YAL002W 11_2_d 0.3 0.1 # … with 488,092 more rows &gt; sk_tidy %&gt;% dcast(gene + segregant ~ condition, + value.var = &quot;expression&quot;) %&gt;% + filter(gene == &quot;YAL002W&quot;) %&gt;% + ggplot(aes(x = glucose, y = ethanol)) + + geom_point() + theme_bw() + + theme(legend.position = &quot;none&quot;) "],
["further-reading.html", "11 Further Reading 11.1 Additional Examples 11.2 Additional dplyr Features", " 11 Further Reading 11.1 Additional Examples You should study additional tutorials of dplyr that utilize other data sets: Read the dplyr introductory vignette Read the examples given in the R for Data Science assigned reading 11.2 Additional dplyr Features We’ve only scratched the surface – many interesting demos of dplyr can be found online dplyr can work with other data frame backends such as SQL databases There is an SQL interface for relational databases via the DBI package dplyr can be integrated with the data.table package for large fast tables There is a healthy rivalry between dplyr and data.table "],
["exploratory-data-analysis.html", "12 Exploratory Data Analysis 12.1 What is EDA? 12.2 Descriptive Statistics Examples 12.3 Components of EDA 12.4 Data Sets", " 12 Exploratory Data Analysis 12.1 What is EDA? Exploratory data analysis (EDA) is the process of analzying data to uncover their key features. John Tukey pioneered this framework, writing a seminal book on the topic (called Exploratory Data Analysis). EDA involves calculating numerical summaries of data, visualizing data in a variety of ways, and considering interesting data points. Before any model fitting is done to data, some exploratory data analysis should always be performed. 12.2 Descriptive Statistics Examples Facebook’s Visualizing Friendships (side note: a discussion) Hans Rosling: Debunking third-world myths with the best stats you’ve ever seen Flowing Data’s A Day in the Life of Americans 12.3 Components of EDA EDA involves calculating quantities and visualizing data for: Basic sanity checks Checking for missing data Characterizing the distributional properties of the data Characterizing relationships among variables and observations Dimension reduction Model formulation Hypothesis generation … and there are possible many more activities one can do. 12.4 Data Sets For the majority of this chapter, we will use some simple data sets to demonstrate the ideas. 12.4.1 Data mtcars Load the mtcars data set: &gt; library(&quot;tidyverse&quot;) # why load tidyverse? &gt; data(&quot;mtcars&quot;, package=&quot;datasets&quot;) &gt; mtcars &lt;- as_tibble(mtcars) &gt; head(mtcars) # A tibble: 6 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 12.4.2 Data mpg Load the mpg data set: &gt; data(&quot;mpg&quot;, package=&quot;ggplot2&quot;) &gt; head(mpg) # A tibble: 6 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… 3 audi a4 2 2008 4 manua… f 20 31 p comp… 4 audi a4 2 2008 4 auto(… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… 12.4.3 Data diamonds Load the diamonds data set: &gt; data(&quot;diamonds&quot;, package=&quot;ggplot2&quot;) &gt; head(diamonds) # A tibble: 6 x 10 carat cut color clarity depth table price x y z &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 12.4.4 Data gapminder Load the gapminder data set: &gt; library(&quot;gapminder&quot;) &gt; data(&quot;gapminder&quot;, package=&quot;gapminder&quot;) &gt; gapminder &lt;- as_tibble(gapminder) &gt; head(gapminder) # A tibble: 6 x 6 country continent year lifeExp pop gdpPercap &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. 2 Afghanistan Asia 1957 30.3 9240934 821. 3 Afghanistan Asia 1962 32.0 10267083 853. 4 Afghanistan Asia 1967 34.0 11537966 836. 5 Afghanistan Asia 1972 36.1 13079460 740. 6 Afghanistan Asia 1977 38.4 14880372 786. "],
["numerical-summaries-of-data.html", "13 Numerical Summaries of Data 13.1 Useful Summaries 13.2 Measures of Center 13.3 Mean, Median, and Mode in R 13.4 Quantiles and Percentiles 13.5 Five Number Summary 13.6 Measures of Spread 13.7 Variance, SD, and IQR in R 13.8 Identifying Outliers 13.9 Application to mtcars Data 13.10 Measuring Symmetry 13.11 skewness() Function 13.12 Measuring Tails 13.13 Excess Kurtosis 13.14 kurtosis() Function 13.15 Visualizing Skewness and Kurtosis 13.16 Covariance and Correlation", " 13 Numerical Summaries of Data 13.1 Useful Summaries Center: mean, median, mode Quantiles: percentiles, five number summaries Spread: standard deviation, variance, interquartile range Outliers Shape: skewness, kurtosis Concordance: correlation, quantile-quantile plots 13.2 Measures of Center Suppose we have data points \\(x_1, x_2, \\ldots, x_n\\). Mean: \\[\\overline{x} = \\frac{x_1 + x_2 + \\cdots + x_n}{n}\\] Median: Order the points \\(x_{(1)} \\leq x_{(2)} \\leq \\cdots \\leq x_{(n)}\\). The median is the middle value: - \\(x_{((n+1)/2)}\\) if \\(n\\) is odd - \\((x_{(n/2)} + x_{(n/2+1)})/2\\) if \\(n\\) is even Mode: The most frequently repeated value among the data (if any). If there are ties, then there is more than one mode. 13.3 Mean, Median, and Mode in R Let’s calculate these quantities in R. &gt; mean(mtcars$mpg) [1] 20.09062 &gt; median(mtcars$mpg) [1] 19.2 &gt; &gt; sample_mode &lt;- function(x) { + as.numeric(names(which(table(x) == max(table(x))))) + } &gt; &gt; sample_mode(round(mtcars$mpg)) [1] 15 21 It appears there is no R base function for calculating the mode. 13.4 Quantiles and Percentiles The \\(p\\)th percentile of \\(x_1, x_2, \\ldots, x_n\\) is a number such that \\(p\\)% of the data are less than this number. The 25th, 50th, and 75th percentiles are called 1st, 2nd, and 3rd “quartiles”, respectively. These are sometimes denoted as Q1, Q2, and Q3. The median is the 50th percentile aka the 2nd quartile aka Q2. In general, \\(q\\)-quantiles are cut points that divide the data into \\(q\\) approximately equally sized groups. The cut points are the percentiles \\(1/q, 2/q, \\ldots, (q-1)/q.\\) 13.5 Five Number Summary The “five number summary” is the minimum, the three quartiles, and the maximum. This can be calculated via fivenum() and summary(). They can produce different values. Finally, quantile() extracts any set of percentiles. &gt; fivenum(mtcars$mpg) [1] 10.40 15.35 19.20 22.80 33.90 &gt; summary(mtcars$mpg) Min. 1st Qu. Median Mean 3rd Qu. Max. 10.40 15.43 19.20 20.09 22.80 33.90 &gt; &gt; quantile(mtcars$mpg, prob=seq(0, 1, 0.25)) 0% 25% 50% 75% 100% 10.400 15.425 19.200 22.800 33.900 13.6 Measures of Spread The variance, standard deviation (SD), and interquartile range (IQR) measure the “spread” of the data. Variance: \\[s^2 = \\frac{\\sum_{i=1}^n \\left(x_i - \\overline{x}\\right)^2}{n-1}\\] Standard Deviation: \\(s = \\sqrt{s^2}\\) Iterquartile Range: IQR \\(=\\) Q3 \\(-\\) Q1 The SD and IQR have the same units as the observed data, but the variance is in squared units. 13.7 Variance, SD, and IQR in R Variance: &gt; var(mtcars$mpg) [1] 36.3241 Standard deviation: &gt; sd(mtcars$mpg) [1] 6.026948 Interquartile range: &gt; IQR(mtcars$mpg) [1] 7.375 &gt; diff(fivenum(mtcars$mpg)[c(2,4)]) [1] 7.45 13.8 Identifying Outliers An outlier is an unusual data point. Outliers can be perfectly valid but they can also be due to errors (as can non-outliers). One must define what is meant by an outlier. One definition is a data point that less than Q1 or greater than Q3 by 1.5 \\(\\times\\) IQR or more. Another definition is a data point whose difference from the mean is greater than 3 \\(\\times\\) SD or more. For Normal distributed data (bell curve shaped), the probability of this is less than 0.27%. 13.9 Application to mtcars Data &gt; sd_units &lt;- abs(mtcars$wt - mean(mtcars$wt))/sd(mtcars$wt) &gt; sum(sd_units &gt; 3) [1] 0 &gt; max(sd_units) [1] 2.255336 &gt; &gt; iqr_outlier_cuts &lt;- fivenum(mtcars$wt)[c(2,4)] + + c(-1.5, 1.5)*diff(fivenum(mtcars$wt)[c(2,4)]) &gt; sum(mtcars$wt &lt; iqr_outlier_cuts[1] | + mtcars$wt &gt; iqr_outlier_cuts[2]) [1] 2 13.10 Measuring Symmetry The skewness statistic measures symmetry of the data. It is calculated by: \\[ \\gamma = \\frac{\\sum_{i=1}^n (x_i - \\overline{x})^3/n}{s^3} \\] A negative number is left-skewed, and a positive number is right-skewed. Note: Use of \\(n\\) vs. \\(n-1\\) may vary – check the code. 13.11 skewness() Function In R, there is a function call skewness() from the moments package for calculating this statistic on data. &gt; library(moments) &gt; gapminder %&gt;% filter(year==2007) %&gt;% select(gdpPercap) %&gt;% + skewness() gdpPercap 1.211228 &gt; gapminder %&gt;% filter(year==2007) %&gt;% select(gdpPercap) %&gt;% + log() %&gt;% skewness() gdpPercap -0.1524203 &gt; rnorm(10000) %&gt;% skewness() [1] 0.005799917 13.12 Measuring Tails The tails of a distribution are often described as being heavy or light depending on how slowly they descend. This can be measured through statistic called kurtosis: \\[ \\kappa = \\frac{\\sum_{i=1}^n (x_i - \\overline{x})^4/n}{s^4} \\] As with skewness \\(\\gamma\\), use of \\(n\\) vs \\(n-1\\) may vary. 13.13 Excess Kurtosis For a standard Normal distribution (mean 0 and standard deviation 1), the kurtosis is on average 3. Therefore, a measure called “excess kurtosis” is defined to be \\(\\kappa - 3\\). A positive value implies heavier tails and a negative value implies lighter tails. 13.14 kurtosis() Function In R, there is a function call kurtosis() from the moments package for calculating this statistic on data. &gt; library(moments) &gt; gapminder %&gt;% filter(year==2007) %&gt;% select(gdpPercap) %&gt;% + kurtosis() gdpPercap 3.29593 &gt; gapminder %&gt;% filter(year==2007) %&gt;% select(gdpPercap) %&gt;% + log() %&gt;% kurtosis() gdpPercap 1.871608 &gt; rnorm(10000) %&gt;% kurtosis() [1] 2.955853 13.15 Visualizing Skewness and Kurtosis 13.16 Covariance and Correlation It is often the case that two or more quantitative variables are measured on each unit of observation (such as an individual). We are then often interested in characterizing how pairs of variables are associated or how they vary together. Two common measures for this are called “covariance” and “correlation”, both of which are most well suited for measuring linear associations 13.16.1 Covariance Suppose we observe \\(n\\) pairs of data \\((x_1, y_1), (x_2, y_2), \\ldots, (x_n, y_n)\\). Their sample covariance is \\[ {\\operatorname{cov}}_{xy} = \\frac{\\sum_{i=1}^n (x_i - \\overline{x}) (y_i - \\overline{y})}{(n-1)}, \\] which meausers how the two variables “covary” about their respective means. Large positive numbers indicate concordance of deviations from the mean, and large negative numbers indicated discordance (so opposite sides of the mean). 13.16.2 Pearson Correlation Pearson correlation is sample covariance scaled by the variables’ standard deviations, meaning correlation is a unitless measure of variation about the mean. It is defined by \\[\\begin{eqnarray} r_{xy} &amp; = &amp; \\frac{\\sum_{i=1}^n (x_i - \\overline{x}) (y_i - \\overline{y})}{\\sqrt{\\sum_{i=1}^n (x_i - \\overline{x})^2 \\sum_{i=1}^n (y_i - \\overline{y})^2}} \\\\ \\ &amp; = &amp; \\frac{\\sum_{i=1}^n (x_i - \\overline{x}) (y_i - \\overline{y})}{(n-1) s_x s_y} \\\\ \\ &amp; = &amp; \\frac{ \\operatorname{cov}_{xy}}{s_x s_y} \\end{eqnarray}\\] where \\(s_x\\) and \\(s_y\\) are the sample standard deviations of each measured variable. Note that \\(-1 \\leq r_{xy} \\leq 1\\). 13.16.3 Spearman Correlation There are other ways to measure correlation that are less reliant on linear trends in covariation and are also more robust to outliers. Specifically, one can convert each measured variable to ranks by size (1 for the smallest, \\(n\\) for the largest) and then use a formula for correlation designed for these ranks. One popular measure of rank-based correlation is the Spearman correlation. &gt; x &lt;- rnorm(500) &gt; y &lt;- x + rnorm(500) &gt; cor(x, y, method=&quot;pearson&quot;) [1] 0.7542651 &gt; cor(x, y, method=&quot;spearman&quot;) [1] 0.7499555 &gt; x &lt;- rnorm(500) &gt; y &lt;- x + rnorm(500, sd=2) &gt; cor(x, y, method=&quot;pearson&quot;) [1] 0.5164903 &gt; cor(x, y, method=&quot;spearman&quot;) [1] 0.5093092 &gt; x &lt;- c(rnorm(499), 100) &gt; y &lt;- c(rnorm(499), 100) &gt; cor(x, y, method=&quot;pearson&quot;) [1] 0.9528564 &gt; cor(x, y, method=&quot;spearman&quot;) [1] -0.02133551 "],
["data-visualization-basics.html", "14 Data Visualization Basics 14.1 Plots 14.2 R Base Graphics 14.3 Read the Documentation 14.4 Barplot 14.5 Boxplot 14.6 Constructing Boxplots 14.7 Boxplot with Outliers 14.8 Histogram 14.9 Histogram with More Breaks 14.10 Density Plot 14.11 Boxplot (Side-By-Side) 14.12 Stacked Barplot 14.13 Scatterplot 14.14 Quantile-Quantile Plots", " 14 Data Visualization Basics 14.1 Plots Single variables: Barplot Boxplot Histogram Density plot Two or more variables: Side-by-Side Boxplots Stacked Barplot Scatterplot 14.2 R Base Graphics We’ll first plodding through “R base graphics”, which means graphics functions that come with R. By default they are very simple. However, they can be customized a lot, but it takes a lot of work. Also, the syntax varies significantly among plot types and some think the syntax is not user-friendly. We will consider a very highly used graphics package next week, called ggplot2 that provides a “grammar of graphics”. It hits a sweet spot of “flexibility vs. complexity” for many data scientists. 14.3 Read the Documentation For all of the plotting functions covered below, read the help files. &gt; ?barplot &gt; ?boxplot &gt; ?hist &gt; ?density &gt; ?plot &gt; ?legend 14.4 Barplot &gt; cyl_tbl &lt;- table(mtcars$cyl) &gt; barplot(cyl_tbl, xlab=&quot;Cylinders&quot;, ylab=&quot;Count&quot;) 14.5 Boxplot &gt; boxplot(mtcars$mpg, ylab=&quot;MPG&quot;, col=&quot;lightgray&quot;) 14.6 Constructing Boxplots The top of the box is Q3 The line through the middle of the box is the median The bottom of the box is Q1 The top whisker is the minimum of Q3 + 1.5 \\(\\times\\) IQR or the largest data point The bottom whisker is the maximum of Q1 - 1.5 \\(\\times\\) IQR or the smallest data point Outliers lie outside of (Q1 - 1.5 \\(\\times\\) IQR) or (Q3 + 1.5 \\(\\times\\) IQR), and they are shown as points Outliers are calculated using the fivenum() function 14.7 Boxplot with Outliers &gt; boxplot(mtcars$wt, ylab=&quot;Weight (1000 lbs)&quot;, + col=&quot;lightgray&quot;) 14.8 Histogram &gt; hist(mtcars$mpg, xlab=&quot;MPG&quot;, main=&quot;&quot;, col=&quot;lightgray&quot;) 14.9 Histogram with More Breaks &gt; hist(mtcars$mpg, breaks=12, xlab=&quot;MPG&quot;, main=&quot;&quot;, col=&quot;lightgray&quot;) 14.10 Density Plot &gt; plot(density(mtcars$mpg), xlab=&quot;MPG&quot;, main=&quot;&quot;) &gt; polygon(density(mtcars$mpg), col=&quot;lightgray&quot;, border=&quot;black&quot;) 14.11 Boxplot (Side-By-Side) &gt; boxplot(mpg ~ cyl, data=mtcars, xlab=&quot;Cylinders&quot;, + ylab=&quot;MPG&quot;, col=&quot;lightgray&quot;) 14.12 Stacked Barplot &gt; counts &lt;- table(mtcars$cyl, mtcars$gear) &gt; counts 3 4 5 4 1 8 2 6 2 4 1 8 12 0 2 &gt; barplot(counts, main=&quot;Number of Gears and Cylinders&quot;, + xlab=&quot;Gears&quot;, col=c(&quot;blue&quot;,&quot;red&quot;, &quot;lightgray&quot;)) &gt; legend(x=&quot;topright&quot;, title=&quot;Cyl&quot;, + legend = rownames(counts), + fill = c(&quot;blue&quot;,&quot;red&quot;, &quot;lightgray&quot;)) 14.13 Scatterplot &gt; plot(mtcars$wt, mtcars$mpg, xlab=&quot;Weight (1000 lbs)&quot;, + ylab=&quot;MPG&quot;) 14.14 Quantile-Quantile Plots Quantile-quantile plots display the quantiles of: two samples of data a sample of data vs a theoretical distribution The first type allows one to assess how similar the distributions are of two samples of data. The second allows one to assess how similar a sample of data is to a theoretical distribution (often Normal with mean 0 and standard deviation 1). &gt; qqnorm(mtcars$mpg, main=&quot; &quot;) &gt; qqline(mtcars$mpg) # line through Q1 and Q3 &gt; before1980 &lt;- gapminder %&gt;% filter(year &lt; 1980) %&gt;% + select(lifeExp) %&gt;% unlist() &gt; after1980 &lt;- gapminder %&gt;% filter(year &gt; 1980) %&gt;% + select(lifeExp) %&gt;% unlist() &gt; qqplot(before1980, after1980); abline(0,1) &gt; ggplot(mtcars) + stat_qq(aes(sample = mpg)) &gt; ggplot(gapminder) + stat_qq(aes(sample=lifeExp)) &gt; ggplot(gapminder) + + stat_qq(aes(sample=lifeExp, color=continent)) "],
["a-grammar-of-graphics.html", "15 A Grammar of Graphics 15.1 Rationale 15.2 Package ggplot2 15.3 Pieces of the Grammar 15.4 Geometries 15.5 Call Format 15.6 Layers 15.7 Placement of the aes() Call 15.8 Original Publications 15.9 Documentation 15.10 Barplots 15.11 Boxplots and Violin Plots 15.12 Histograms and Density Plots 15.13 Line Plots 15.14 Scatterplots 15.15 Axis Scales 15.16 Scatterplot Smoothers 15.17 Overplotting 15.18 Labels and Legends 15.19 Facets 15.20 Colors 15.21 Saving Plots 15.22 Dynamic Visualization 15.23 Themes", " 15 A Grammar of Graphics 15.1 Rationale A grammar for communicating data visualization: Data: the data set we are plotting Aesthetics: the variation or relationships in the data we want to visualize Geometries: the geometric object by which we render the aesthetics Coordinates: the coordinate system used (not covered here) Facets: the layout of plots required to visualize the data Other Options: any other customizations we wish to make, such as changing the color scheme or labels These are strung together like words in a sentence. 15.2 Package ggplot2 The R package ggplot2 implements a grammar of graphics along these lines. First, let’s load ggplot2: &gt; library(ggplot2) Now let’s set a theme (more on this later): &gt; theme_set(theme_bw()) 15.3 Pieces of the Grammar ggplot() aes() geom_*() facet_*() scale_*() theme() labs() The * is a placeholder for a variety of terms that we will consider. 15.4 Geometries Perhaps the most important aspect of ggplot2 is to understand the “geoms”. We will cover the following: geom_bar() geom_boxplot() geom_violin() geom_histogram() geom_density() geom_line() geom_point() geom_smooth() geom_hex() 15.5 Call Format The most basic ggplot2 plot is made with something like: ggplot(data = &lt;DATA FRAME&gt;) + geom_*(mapping = aes(x = &lt;VAR X&gt;, y = &lt;VAR Y&gt;)) where &lt;DATA FRAME&gt; is a data frame and &lt;VAR X&gt; and &lt;VAR Y&gt; are variables (i.e., columns) from this data frame. Recall geom_* is a placeholder for a geometry such as geom_boxplot. 15.6 Layers There’s a complex “layers” construct occurring in the ggplot2 package. However, for our purposes, it suffices to note that the different parts of the plots are layered together through the + operator: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, color=drv)) + + geom_smooth(mapping = aes(x = displ, y = hwy, color=drv)) + + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Drivetrain&quot;) + + labs(title = &quot;Highway MPG By Drivetrain and Displacement&quot;, + x = &quot;Displacement&quot;, y = &quot;Highway MPG&quot;) 15.7 Placement of the aes() Call In the previous slide, we saw that the same aes() call was made for two geom’s. When this is the case, we may more simply call aes() from within ggplot(): &gt; ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + + geom_point() + + geom_smooth() + + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Drivetrain&quot;) + + labs(title = &quot;Highway MPG By Drivetrain and Displacement&quot;, + x = &quot;Displacement&quot;, y = &quot;Highway MPG&quot;) There may be cases where different geom’s are layered and require different aes() calls. This is something to keep in mind as we go through the specifics of the ggplot2 package. 15.8 Original Publications Wickham, H. (2010) A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, 19 (1): 3–28. This paper designs an implementation of The Grammar of Graphics by Leland Wilkinson (published in 2005). 15.9 Documentation In R: help(package=&quot;ggplot2&quot;) http://docs.ggplot2.org/current/ http://www.cookbook-r.com/Graphs/ ggplot2: Elegant Graphics for Data Analysis (somewhat outdated, but gives clear rationale) 15.10 Barplots The geom_bar() layer forms a barplot and only requires an x assignment in the aes() call: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut)) Color in the bars by assigning fill in geom_bar(), but outside of aes(): &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut), fill = &quot;tomato&quot;) Color within the bars according to a variable by assigning fill in geom_bar() inside of aes(): &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) When we use fill = clarity within aes(), we see that it shows the proportion of each clarity value within each cut value: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = clarity)) By setting position = &quot;dodge&quot; outside of aes(), it shows bar charts for the clarity values within each cut value: &gt; ggplot(data = diamonds) + + geom_bar(mapping= aes(x = cut, fill = clarity), + position = &quot;dodge&quot;) By setting position = &quot;fill&quot;, it shows the proportion of clarity values within each cut value and no longer shows the cut values: &gt; ggplot(data = diamonds) + + geom_bar(mapping=aes(x = cut, fill = clarity), + position = &quot;fill&quot;) + + labs(x = &quot;cut&quot;, y = &quot;relative proporition within cut&quot;) 15.11 Boxplots and Violin Plots The geom_boxplot() layer forms a boxplot and requires both x and y assignments in the aes() call, even when plotting a single boxplot: &gt; ggplot(data = mpg) + + geom_boxplot(mapping = aes(x = 1, y = hwy)) Color in the boxes by assigning fill in geom_boxplot(), but outside of aes(): &gt; ggplot(data = mpg) + + geom_boxplot(mapping = aes(x = 1, y = hwy), + fill=&quot;lightblue&quot;) + + labs(x=NULL) Show a boxplot for the y values occurring within each x factor level by making these assignments in aes(): &gt; ggplot(data = mpg) + + geom_boxplot(mapping = aes(x = factor(cyl), y = hwy)) By assigning the fill argument within aes(), we can color each boxplot according to the x-axis factor variable: &gt; ggplot(data = mpg) + + geom_boxplot(mapping = aes(x = factor(cyl), y = hwy, + fill = factor(cyl))) The geom_jitter() function plots the data points and randomly jitters them so we can better see all of the points: &gt; ggplot(data = mpg, mapping = aes(x=factor(cyl), y=hwy)) + + geom_boxplot(fill = &quot;lightblue&quot;) + + geom_jitter(width = 0.2) A violin plot, called via geom_violin(), is similar to a boxplot, except shows a density plot turned on its side and reflected across its vertical axis: &gt; ggplot(data = mpg) + + geom_violin(mapping = aes(x = drv, y = hwy)) Add a geom_jitter() to see how the original data points relate to the violin plots: &gt; ggplot(data = mpg, mapping = aes(x = drv, y = hwy)) + + geom_violin(adjust=1.2) + + geom_jitter(width=0.2, alpha=0.5) Boxplot example on the gapminder data: &gt; ggplot(gapminder, aes(x = continent, y = lifeExp)) + + geom_boxplot(outlier.colour = &quot;red&quot;) + + geom_jitter(width = 0.1, alpha = 0.25) Analogous violin plot example on the gapminder data: &gt; ggplot(gapminder, aes(x = continent, y = lifeExp)) + + geom_violin() + + geom_jitter(width = 0.1, alpha = 0.25) 15.12 Histograms and Density Plots We can create a histogram using the geom_histogram() layer, which requires an x argument only in the aes() call: &gt; ggplot(gapminder) + + geom_histogram(mapping = aes(x=lifeExp)) We can change the bin width directly in the histogram, which is an intuitive parameter to change based on visual inspection: &gt; ggplot(gapminder) + + geom_histogram(mapping = aes(x=lifeExp), binwidth=5) The bins are sometimes centered in an unexpected manner in ggplot2: &gt; ggplot(diamonds) + + geom_histogram(mapping = aes(x=price), binwidth = 1000) Let’s fix how the bins are centered (make center half of binwidth). &gt; ggplot(diamonds) + + geom_histogram(mapping = aes(x=price), binwidth = 1000, + center=500) Instead of counts on the y-axis, we may instead want the area of the bars to sum to 1, like a probability density: &gt; ggplot(gapminder) + + geom_histogram(mapping = aes(x=lifeExp, y=..density..), + binwidth=5) When we use fill = continent within aes(), we see that it shows the counts of each continent value within each lifeExp bin: &gt; ggplot(gapminder) + + geom_histogram(mapping = aes(x=lifeExp, fill = continent), + binwidth = 5) Display a density plot using the geom_density() layer: &gt; ggplot(gapminder) + + geom_density(mapping = aes(x=lifeExp)) Employ the arguments color=&quot;blue&quot; and fill=&quot;lightblue&quot; outside of the aes() call to include some colors: &gt; ggplot(gapminder) + + geom_density(mapping = aes(x=lifeExp), color=&quot;blue&quot;, + fill=&quot;lightblue&quot;) By utilizing color=as.factor(year) we plot a density of lifeExp stratified by each year value: &gt; ggplot(gapminder) + + geom_density(aes(x=lifeExp, color=as.factor(year)), + size=1.2) Overlay a density plot and a histogram together: &gt; ggplot(gapminder, mapping = aes(x=lifeExp)) + + geom_histogram(aes(y=..density..), color=&quot;black&quot;, + fill=&quot;white&quot;) + + geom_density(fill=&quot;lightblue&quot;, alpha=.5) 15.13 Line Plots babynames Revisited Let’s first create a data frame that captures the number of times “John” is registered in males per year: &gt; library(&quot;babynames&quot;) &gt; john &lt;- babynames %&gt;% filter(sex==&quot;M&quot;, name==&quot;John&quot;) &gt; head(john) # A tibble: 6 x 5 year sex name n prop &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 1880 M John 9655 0.0815 2 1881 M John 8769 0.0810 3 1882 M John 9557 0.0783 4 1883 M John 8894 0.0791 5 1884 M John 9388 0.0765 6 1885 M John 8756 0.0755 We can geom_lines() to plot a line showing the popularity of “John” over time: &gt; ggplot(data = john) + + geom_line(mapping = aes(x=year, y=prop), size=1.5) Now let’s look at a name that occurs nontrivially in males and females: &gt; kelly &lt;- babynames %&gt;% filter(name==&quot;Kelly&quot;) &gt; ggplot(data = kelly) + + geom_line(mapping = aes(x=year, y=prop, color=sex), + size=1.5) 15.14 Scatterplots The layer geom_point() produces a scatterplot, and the aes() call requires x and y assignment: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy)) Give the points a color: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy), + color = &quot;blue&quot;) Color the points according to a factor variable by including color = class within the aes() call: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, + color = class)) Increase the size of points with size=2 outside of the aes() call: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, + color = class), size=2) Vary the size of the points according to the pop variable: &gt; gapminder %&gt;% filter(year==2007) %&gt;% ggplot() + + geom_point(aes(x = log(gdpPercap), y = lifeExp, + size = pop)) Vary the transparency of the points according to the class factor variable by setting alpha=class within the aes() call: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, + alpha = class)) Warning: Using alpha for a discrete variable is not advised. Vary the shape of the points according to the class factor variable by setting alpha=class within the aes() call (maximum 6 possible shapes – oops!): &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, + shape = class)) Color the points according to the cut variable by setting color=cut within the aes() call: &gt; ggplot(data = diamonds) + + geom_point(mapping = aes(x=carat, y=price, color=cut), + alpha=0.7) Color the points according to the clarity variable by setting color=clarity within the aes() call: &gt; ggplot(data = diamonds) + + geom_point(mapping=aes(x=carat, y=price, color=clarity), + alpha=0.3) Override the alpha=0.3 in the legend: &gt; ggplot(data=diamonds) + + geom_point(mapping=aes(x=carat, y=price, color=clarity), + alpha=0.3) + + guides(color=guide_legend(override.aes = list(alpha = 1))) 15.15 Axis Scales A different way to take the log of gdpPercap: &gt; gapminder %&gt;% filter(year==2007) %&gt;% ggplot() + + geom_point(aes(x = gdpPercap, y = lifeExp, + size = pop)) + + scale_x_log10() The price variable seems to be significantly right-skewed: &gt; ggplot(diamonds) + + geom_boxplot(aes(x=color, y=price)) We can try to reduce this skewness by rescaling the variables. We first try to take the log(base=10) of the price variable via scale_y_log10(): &gt; ggplot(diamonds) + + geom_boxplot(aes(x=color, y=price)) + + scale_y_log10() Let’s repeat this on the analogous violing plots: &gt; ggplot(diamonds) + + geom_violin(aes(x=color, y=price)) + + scale_y_log10() The relationship between carat and price is nonlinear. Let’s explore different transformations to find an approximately linear relationship. &gt; ggplot(data = diamonds) + + geom_point(mapping=aes(x=carat, y=price, color=clarity), + alpha=0.3) First try to take the squareroot of the the price variable: &gt; ggplot(data = diamonds) + + geom_point(aes(x=carat, y=price, color=clarity), + alpha=0.3) + + scale_y_sqrt() Now let’s try to take log(base=10) on both the carat and price variables: &gt; ggplot(data = diamonds) + + geom_point(aes(x=carat, y=price, color=clarity), alpha=0.3) + + scale_y_log10(breaks=c(1000,5000,10000)) + + scale_x_log10(breaks=1:5) Forming a violin plot of price stratified by clarity and transforming the price variable yields an interesting relationship in this data set: &gt; ggplot(diamonds) + + geom_violin(aes(x=clarity, y=price, fill=clarity), + adjust=1.5) + + scale_y_log10() 15.16 Scatterplot Smoothers Fitting “Smoothers” and Other Models to Scatterplots Later this semester, we will spend several weeks learning how to explain or predict an outcome variable in terms of predictor variables We will briefly show here how to plot some simple model fits to scatterplots You may want to return to these slides later in the semester once we cover modeling in more detail Recall the scatterplot showing the relationship between highway mpg and displacement. How can we plot a smoothed relationship between these two variables? &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy)) Plot a smoother with geom_smooth() using the default settings (other than removing the error bands): &gt; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + + geom_point() + + geom_smooth(se=FALSE) The default smoother here is a “loess” smoother. Let’s compare that to the least squares regresson line: &gt; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + + geom_point() + + geom_smooth(aes(colour = &quot;loess&quot;), method = &quot;loess&quot;, se = FALSE) + + geom_smooth(aes(colour = &quot;lm&quot;), method = &quot;lm&quot;, se = FALSE) Now let’s plot a smoother to the points stratified by the drv variable: &gt; ggplot(data=mpg, mapping = aes(x = displ, y = hwy, + linetype = drv)) + + geom_point() + + geom_smooth(se=FALSE) Instead of different line types, let’s instead differentiate them by line color: &gt; ggplot(data = mpg, mapping = aes(x = displ, y = hwy, + color=drv)) + + geom_point() + + geom_smooth(se=FALSE) 15.17 Overplotting Definition Overplotting occurs when there are many observations, resulting in many objects being plotted on top of each other For example, the diamonds data set has 53940 observations per variable Let’s explore some ways to deal with overplotting Here is an example of an overplotted scatterplot: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_point() Let’s reduce the alpha of the points: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_point(alpha=0.1) Let’s further reduce the alpha: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_point(alpha=0.01) We can bin the points into hexagons, and report how many points fall within each bin. We use the geom_hex() layer to do this: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_hex() Let’s try to improve the color scheme: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_hex() + + scale_fill_gradient2(low=&quot;lightblue&quot;, mid=&quot;purple&quot;, high=&quot;black&quot;, + midpoint=3000) We can combine the scale transformation used earlier with the “hexbin” plotting method: &gt; ggplot(data = diamonds, mapping = aes(x=carat, y=price)) + + geom_hex(bins=20) + + scale_x_log10(breaks=1:5) + scale_y_log10(breaks=c(1000,5000,10000)) 15.18 Labels and Legends Here’s how you can change the axis labels and give the plot a title: &gt; ggplot(data = mpg) + + geom_boxplot(mapping = aes(x = factor(cyl), y = hwy)) + + labs(title=&quot;Highway MPG by Cylinders&quot;,x=&quot;Cylinders&quot;, + y=&quot;Highway MPG&quot;) You can remove the legend to a plot by the following: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + theme(legend.position=&quot;none&quot;) The legend can be placed on the “top”, “bottom”, “left”, or “right”: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + theme(legend.position=&quot;bottom&quot;) The legend can be moved inside the plot itself: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + theme(legend.position=c(0.15,0.75)) Change the name of the legend: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + scale_fill_discrete(name=&quot;Diamond\\nCut&quot;) Change the labels within the legend: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + scale_fill_discrete(labels=c(&quot;F&quot;, &quot;G&quot;, &quot;VG&quot;, &quot;P&quot;, &quot;I&quot;)) 15.19 Facets Here is the histogram of the displ variable from the mpg data set: &gt; ggplot(mpg) + geom_histogram(mapping=aes(x=displ), + binwidth=0.25) The facet_wrap() layer allows us to stratify the displ variable according to cyl, and show the histograms for the strata in an organized fashion: &gt; ggplot(mpg) + + geom_histogram(mapping=aes(x=displ), binwidth=0.25) + + facet_wrap(~ cyl) Here is facet_wrap() applied to displ startified by the drv variable: &gt; ggplot(mpg) + + geom_histogram(mapping=aes(x=displ), binwidth=0.25) + + facet_wrap(~ drv) We can stratify by two variable simultaneously by using the facet_grid() layer: &gt; ggplot(mpg) + + geom_histogram(mapping=aes(x=displ), binwidth=0.25) + + facet_grid(drv ~ cyl) Let’s carry out a similar faceting on the diamonds data over the next four plots: &gt; ggplot(diamonds) + + geom_histogram(mapping=aes(x=price), binwidth=500) Stratify price by clarity: &gt; ggplot(diamonds) + + geom_histogram(mapping=aes(x=price), binwidth=500) + + facet_wrap(~ clarity) Stratify price by clarity, but allow each y-axis range to be different by including the scale=&quot;free_y&quot; argument: &gt; ggplot(diamonds) + + geom_histogram(mapping=aes(x=price), binwidth=500) + + facet_wrap(~ clarity, scale=&quot;free_y&quot;) Jointly stratify price by cut and clarify: &gt; ggplot(diamonds) + + geom_histogram(mapping=aes(x=price), binwidth=500) + + facet_grid(cut ~ clarity) + + scale_x_continuous(breaks=9000) 15.20 Colors 15.20.1 Finding Colors A list of named colors in R (e.g., “lightblue”) RColorBrewer package The Crayola crayon colors from the broman package – use brocolors(set=&quot;crayons&quot;) Color blind palette: &gt; cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, + &quot;#D55E00&quot;, &quot;#CC79A7&quot;) 15.20.2 Some Useful Layers scale_fill_manual() scale_color_manual() scale_fill_gradient() scale_color_gradient() Manually determine colors to fill the barplot using the color blind palette defined above, cbPalette: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut, fill = cut)) + + scale_fill_manual(values=cbPalette) Manually determine point colors using the color blind palette defined above, cbPalette: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, color = class), size=2) + + scale_color_manual(values=cbPalette) Fill the histogram bars using a color gradient by their counts, where we determine the endpoint colors: &gt; ggplot(data = mpg) + + geom_histogram(aes(x=hwy, fill=..count..)) + + scale_fill_gradient(low=&quot;blue&quot;, high=&quot;red&quot;) Color the points based on a gradient formed from the quantitative variable, displ, where we we determine the endpoint colors: &gt; ggplot(data = mpg) + + geom_point(aes(x=hwy, y=cty, color=displ), size=2) + + scale_color_gradient(low=&quot;blue&quot;, high=&quot;red&quot;) An example of using the palette “Set1” from the RColorBrewer package, included in ggplot2: &gt; ggplot(diamonds) + + geom_density(mapping = aes(x=price, color=clarity)) + + scale_color_brewer(palette = &quot;Set1&quot;) Another example of using the palette “Set1” from the RColorBrewer package, included in ggplot2: &gt; ggplot(data = mpg) + + geom_point(mapping = aes(x = displ, y = hwy, color = class)) + + scale_color_brewer(palette = &quot;Set1&quot;) The gapminder package comes with its own set of colors, country_colors. &gt; ggplot(subset(gapminder, continent != &quot;Oceania&quot;), + aes(x = year, y = lifeExp, group = country, + color = country)) + + geom_line(show.legend = FALSE) + facet_wrap(~ continent) + + scale_color_manual(values = country_colors) 15.21 Saving Plots 15.21.1 Saving Plots as Variables Pieces of the plots can be saved as variables, which is particular useful to explortatory data analysis. These all produce the same plot: &gt; ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + + geom_point() + + geom_smooth(se=FALSE) &gt; p &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + + geom_point() &gt; p + geom_smooth(se=FALSE) &gt; p &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) &gt; p + geom_point() + geom_smooth(se=FALSE) Try it yourself! 15.21.2 Saving Plots to Files Plots can be saved to many formats using the ggsave() function. Here are some examples: &gt; p &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv)) + + geom_point() + + geom_smooth(se=FALSE) &gt; ggsave(filename=&quot;my_plot.pdf&quot;, plot=p) # saves PDF file &gt; ggsave(filename=&quot;my_plot.png&quot;, plot=p) # saves PNG file Here are the arguments that ggsave() takes: &gt; str(ggsave) function (filename, plot = last_plot(), device = NULL, path = NULL, scale = 1, width = NA, height = NA, units = c(&quot;in&quot;, &quot;cm&quot;, &quot;mm&quot;), dpi = 300, limitsize = TRUE, ...) 15.22 Dynamic Visualization Tools to dynamically interact with data visualizations (and calculations) are becoming increasingly common and straightforward to implement. Here are several examples: Shiny (see also, example from my lab) plotly ggvis animation gganimate &gt; p &lt;- ggplot(gapminder) + + geom_point(aes(x=gdpPercap, y=lifeExp, size = pop, + color = continent, frame = year)) + + scale_x_log10() &gt; gganimate(p, &quot;animation_ex1.gif&quot;, ani.height=400, ani.width=500) The resulting file can be viewed here: https://github.com/jdstorey/asdslectures/blob/master/docs/images/animation_ex1.gif &gt; p &lt;- ggplot(gapminder) + + geom_density(aes(x=lifeExp, color=as.factor(year), + frame=year), + size=1.2) + + scale_color_discrete(name=&quot;year&quot;) &gt; gganimate(p, &quot;animation_ex2.gif&quot;, ani.height=400, ani.width=500) The resulting file can be viewed here: https://github.com/jdstorey/asdslectures/blob/master/docs/images/animation_ex2.gif &gt; p &lt;- ggplot(gapminder) + + geom_density(aes(x=lifeExp, color=as.factor(year), + frame=year, cumulative = TRUE), + size=1.2) + + scale_color_discrete(name=&quot;year&quot;) &gt; gganimate(p, &quot;animation_ex3.gif&quot;, ani.height=400, ani.width=500) The resulting file can be viewed here: https://github.com/jdstorey/asdslectures/blob/master/docs/images/animation_ex3.gif 15.23 Themes 15.23.1 Available Themes See https://r4ds.had.co.nz/graphics-for-communication.html#themes for an explanation of the ggplot2 themes. See also the ggthemes package for additional themes. 15.23.2 Setting a Theme Globally: &gt; theme_set(theme_minimal()) Locally: &gt; ggplot(data = diamonds) + + geom_bar(mapping = aes(x = cut)) + + theme_minimal() "],
["references.html", "References", " References The following books have served as references while writing YARP: Advanced R, by Hadley Wickham Elements of Data Analytic Style, by Jeff Leek R for Data Science, by Hadley Wickham and Garrett Grolemund R Programming for Data Science, by Roger Peng R help files provided by the developers of R and contributed packages Once you have finished reading YARP, I encourage you to read these more comprehensive references. "],
["session-information.html", "Session Information", " Session Information sessionInfo() ## R version 3.6.0 (2019-04-26) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS 10.15.2 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.6.0 magrittr_1.5 bookdown_0.10 tools_3.6.0 ## [5] htmltools_0.3.6 yaml_2.2.0 Rcpp_1.0.1 stringi_1.4.3 ## [9] rmarkdown_1.12 knitr_1.22 stringr_1.4.0 xfun_0.7 ## [13] digest_0.6.18 evaluate_0.13 "]
]
